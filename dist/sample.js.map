{"mappings":"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","sources":["sample.js","../westures/dist/core/dist/src/Gesture.js","../westures/dist/core/dist/src/Point2D.js","../westures/dist/core/dist/src/constants.js","../westures/dist/core/dist/src/PointerData.js","../westures/dist/core/dist/src/utils.js","../westures/dist/core/dist/src/Input.js","../westures/dist/core/dist/src/State.js","../westures/dist/core/dist/src/Region.js","../westures/dist/core/dist/src/Smoothable.js","../westures/dist/src/Pan.js","../westures/dist/core/dist/index.js","../westures/dist/src/Pinch.js","../westures/dist/src/Press.js","../westures/dist/src/Pull.js","../westures/dist/src/Pivotable.js","../westures/dist/src/Rotate.js","../westures/dist/src/Swipe.js","../westures/dist/src/Swivel.js","../westures/dist/src/Tap.js","../westures/dist/src/Track.js","../westures/dist/index.js"],"sourcesContent":["'use strict';\n\nconst westures = require('../westures');\nconst region = new westures.Region();\nconst container = document.querySelector('#container');\n\nconst SIXTY_FPS = 1000 / 60;\nconst FRICTION = 0.95;\nconst MULTI = 7;\nconst LIMIT = 0.1;\nconst MAX_V = 7;\n\nfunction random8Bit() {\n  return Math.floor(Math.random() * 256);\n}\n\nfunction reduce(value) {\n  value *= FRICTION;\n  return (Math.abs(value) < LIMIT) ? 0 : value;\n}\n\n/**\n * Provides an interactable element using westures.\n */\nclass Interactable {\n  constructor(name, color) {\n    this.element = document.createElement('div');\n    this.element.style.backgroundColor = color;\n\n    this.label = document.createElement('h1');\n    this.label.innerText = name;\n\n    this.element.appendChild(this.label);\n    container.appendChild(this.element);\n\n    this.rotation = 0;\n    this.scale = 1;\n    this.x = 0;\n    this.y = 0;\n    this.velocityX = 0;\n    this.velocityY = 0;\n\n    this.animate = false;\n    this.update_fn = this.update.bind(this);\n    this.swipe_interval = null;\n    this.swipe_fn = this.swipeAnimation.bind(this);\n\n    this.setupTracking();\n  }\n\n  /**\n   * Setups up tracking of the interactable element.\n   */\n  setupTracking() {\n    const fns = {\n      end:   (data) => {\n        if (data.active.length == 0) {\n          this.animate = false;\n        }\n      },\n      start: () => {\n        this.animate = true;\n        window.requestAnimationFrame(this.update_fn);\n        clearInterval(this.swipe_interval);\n      },\n    };\n    region.addGesture(new westures.Track(\n      this.element,\n      (data) => fns[data.phase](data),\n      { phases: Object.keys(fns) },\n    ));\n  }\n\n  randomBackground() {\n    const R = random8Bit();\n    const G = random8Bit();\n    const B = random8Bit();\n    this.element.style.backgroundColor = `rgb(${R}, ${G}, ${B})`;\n  }\n\n  addTap(options) {\n    region.addGesture(new westures.Tap(\n      this.element,\n      () => {\n        this.randomBackground();\n      },\n      options,\n    ));\n    return this;\n  }\n\n  addPress(options) {\n    region.addGesture(new westures.Press(\n      this.element,\n      () => {\n        this.randomBackground();\n      },\n      options,\n    ));\n    return this;\n  }\n\n  addRotate(options) {\n    region.addGesture(new westures.Rotate(\n      this.element,\n      (data) => {\n        this.rotation += data.rotation;\n      },\n      options,\n    ));\n    return this;\n  }\n\n  addPan(options) {\n    region.addGesture(new westures.Pan(\n      this.element,\n      (data) => {\n        this.x += data.translation.x;\n        this.y += data.translation.y;\n      },\n      options,\n    ));\n    return this;\n  }\n\n  addSwipe(options) {\n    region.addGesture(new westures.Swipe(\n      this.element,\n      (data) => {\n        const velocity = data.velocity > MAX_V ? MAX_V : data.velocity;\n        this.velocityX = velocity * Math.cos(data.direction) * MULTI;\n        this.velocityY = velocity * Math.sin(data.direction) * MULTI;\n        this.swipe_interval = setInterval(this.swipe_fn, SIXTY_FPS);\n      },\n      options,\n    ));\n    return this;\n  }\n\n  addSwivel(options) {\n    region.addGesture(new westures.Swivel(\n      this.element,\n      (data) => {\n        this.rotation += data.rotation;\n      },\n      {\n        pivotCenter: this.element,\n        ...options,\n      },\n    ));\n    return this;\n  }\n\n  addPinch(options) {\n    region.addGesture(new westures.Pinch(\n      this.element,\n      (data) => {\n        this.scale *= data.scale;\n      },\n      options,\n    ));\n    return this;\n  }\n\n  addPull(options) {\n    region.addGesture(new westures.Pull(\n      this.element,\n      (data) => {\n        this.scale *= data.scale;\n      },\n      {\n        pivotCenter: this.element,\n        ...options,\n      },\n    ));\n    return this;\n  }\n\n  update() {\n    const rotate = `rotate(${this.rotation}rad) `;\n    const translate = `translate(${this.x}px, ${this.y}px) `;\n    const scale = `scale(${this.scale}) `;\n    this.element.style.transform = translate + rotate + scale;\n\n    if (this.animate) {\n      window.requestAnimationFrame(this.update_fn);\n    }\n  }\n\n  swipeAnimation() {\n    this.x += this.velocityX;\n    this.y += this.velocityY;\n    this.velocityX = reduce(this.velocityX);\n    this.velocityY = reduce(this.velocityY);\n    if (this.velocityY === 0 && this.velocityX === 0) {\n      clearInterval(this.swipe_interval);\n    }\n    window.requestAnimationFrame(this.update_fn);\n  }\n}\n\n/* ========================================================================== */\n\nconst NUM_COLOURS = 13;\nconst INTERVAL = Math.floor(360 / NUM_COLOURS);\nconst PALETTE = [];\n\n// Generate a Pastel Rainbow\nfor (let i = 0; i < NUM_COLOURS; i++) {\n  const hue = INTERVAL * i;\n  PALETTE.push(`hsl(${hue}, 100%, 75%)`);\n}\n\nlet cidx = 0;\nfunction nextColour() {\n  return PALETTE[cidx++];\n}\n\n// Basic gestures\nnew Interactable('TAP',    nextColour()).addTap();\nnew Interactable('PAN',    nextColour()).addPan();\nnew Interactable('PINCH',  nextColour()).addPinch();\nnew Interactable('ROTATE', nextColour()).addRotate();\nnew Interactable('SWIPE',  nextColour()).addSwipe();\nnew Interactable('PRESS',  nextColour()).addPress();\nnew Interactable('SWIVEL', nextColour()).addSwivel();\nnew Interactable('PULL',   nextColour()).addPull();\n\n// Mix and match!\n// new Interactable('ROTATE and SWIVEL', 'forestgreen').addRotate().addSwivel();\nnew Interactable(\n  'TAP, PAN, PINCH, SWIPE, and ROTATE\\n(desktop: CTRL to SWIVEL and PULL)',\n  nextColour(),\n).addTap()\n  .addPan({ disableKeys: ['ctrlKey'] })\n  .addPinch()\n  .addRotate()\n  .addSwipe()\n  .addSwivel({ enableKeys: ['ctrlKey'] })\n  .addPull({ enableKeys: ['ctrlKey'] });\nnew Interactable('QUICK DOUBLE TAP', nextColour()).addTap({\n  numTaps: 2,\n});\nnew Interactable('FIVE QUICK TAPS', nextColour()).addTap({\n  maxDelay:  1000,\n  maxRetain: 1000,\n  numTaps:   5,\n});\nnew Interactable('SLOW TAP', nextColour()).addTap({\n  minDelay: 300,\n  maxDelay: 1000,\n});\nnew Interactable('TWO SLOW TAPS', nextColour()).addTap({\n  minDelay:  300,\n  maxDelay:  1000,\n  maxRetain: 2000,\n  numTaps:   2,\n});\n","'use strict';\n\nlet g_id = 0;\n\n/**\n * The Gesture class that all gestures inherit from. A custom gesture class will\n * need to override some or all of the four phase \"hooks\": start, move, end, and\n * cancel.\n *\n * @memberof westures-core\n *\n * @param {string} type - The name of the gesture.\n * @param {Element} element - The element to which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n *    is recognized on the associated element.\n * @param {object} [options] - Generic gesture options\n * @param {westures-core.STATE_KEYS[]} [options.enableKeys=[]] - List of keys\n * which will enable the gesture. The gesture will not be recognized unless one\n * of these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the enable key is always down.\n * @param {westures-core.STATE_KEYS[]} [options.disableKeys=[]] - List of keys\n * which will disable the gesture. The gesture will not be recognized if one of\n * these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the disable key is never down.\n * @param {number} [options.minInputs=1] - The minimum number of pointers that\n * must be active for the gesture to be recognized. Uses >=.\n * @param {number} [options.maxInputs=Number.MAX_VALUE] - The maximum number of\n * pointers that may be active for the gesture to be recognized. Uses <=.\n */\nclass Gesture {\n  constructor(type, element, handler, options = {}) {\n    if (typeof type !== 'string') {\n      throw new TypeError('Gestures require a string type / name');\n    }\n\n    /**\n     * The name of the gesture. (e.g. 'pan' or 'tap' or 'pinch').\n     *\n     * @type {string}\n     */\n    this.type = type;\n\n    /**\n     * The unique identifier for each gesture. This allows for distinctions\n     * across instances of Gestures that are created on the fly (e.g.\n     * gesture-tap-1, gesture-tap-2).\n     *\n     * @type {string}\n     */\n    this.id = `gesture-${this.type}-${g_id++}`;\n\n    /**\n     * The element to which to associate the gesture.\n     *\n     * @type {Element}\n     */\n    this.element = element;\n\n    /**\n     * The function handler to execute when the gesture is recognized on the\n     * associated element.\n     *\n     * @type {Function}\n     */\n    this.handler = handler;\n\n    /**\n     * The options. Can usually be adjusted live, though be careful doing this.\n     *\n     * @type {object}\n     */\n    this.options = { ...Gesture.DEFAULTS, ...options };\n  }\n\n  /**\n   * Determines whether this gesture is enabled.\n   *\n   * @param {westures-core.State} state - The input state object of the current\n   * region.\n   *\n   * @return {boolean} true if enabled, false otherwise.\n   */\n  isEnabled(state) {\n    const count = state.active.length;\n    const event = state.event;\n    const { enableKeys, disableKeys, minInputs, maxInputs } = this.options;\n\n    return (minInputs <= count) && (maxInputs >= count) &&\n      (enableKeys.length === 0 || enableKeys.some(k => event[k])) &&\n      !disableKeys.some(k => event[k]);\n  }\n\n  /**\n   * Event hook for the start phase of a gesture.\n   *\n   * @param {westures-core.State} state - The input state object of the current\n   * region.\n   *\n   * @return {?Object} Gesture is considered recognized if an Object is\n   *    returned.\n   */\n  start() {\n    return null;\n  }\n\n  /**\n   * Event hook for the move phase of a gesture.\n   *\n   * @param {westures-core.State} state - The input state object of the current\n   * region.\n   *\n   * @return {?Object} Gesture is considered recognized if an Object is\n   *    returned.\n   */\n  move() {\n    return null;\n  }\n\n  /**\n   * Event hook for the end phase of a gesture.\n   *\n   * @param {westures-core.State} state - The input state object of the current\n   * region.\n   *\n   * @return {?Object} Gesture is considered recognized if an Object is\n   *    returned.\n   */\n  end() {\n    return null;\n  }\n\n  /**\n   * Event hook for when an input is cancelled.\n   *\n   * @param {westures-core.State} state - The input state object of the current\n   * region.\n   *\n   * @return {?Object} Gesture is considered recognized if an Object is\n   *    returned.\n   */\n  cancel() {\n    return null;\n  }\n\n  /**\n   * Evalutes the given gesture hook, and dispatches any data that is produced\n   * by calling [recognize]{@link westures-core.Gesture#recognize}.\n   *\n   * @param {string} hook - Must be one of 'start', 'move', 'end', or 'cancel'.\n   * @param {westures-core.State} state - The current State instance.\n   */\n  evaluateHook(hook, state) {\n    const data = this[hook](state);\n    if (data) {\n      this.recognize(hook, state, data);\n    }\n  }\n\n  /**\n   * Recognize a Gesture by calling the handler. Standardizes the way the\n   * handler is called so that classes extending Gesture can circumvent the\n   * evaluateHook approach but still provide results that have a common format.\n   *\n   * Note that the properties in the \"data\" object will receive priority when\n   * constructing the results. This can be used to override standard results\n   * such as the phase or the centroid.\n   *\n   * @param {string} hook - Must be one of 'start', 'move', 'end', or 'cancel'.\n   * @param {westures-core.State} state - current input state.\n   * @param {Object} data - Results data specific to the recognized gesture.\n   */\n  recognize(hook, state, data) {\n    this.handler({\n      centroid: state.centroid,\n      event:    state.event,\n      phase:    hook,\n      type:     this.type,\n      target:   this.element,\n      ...data,\n    });\n  }\n}\n\nGesture.DEFAULTS = {\n  enableKeys:  [],\n  disableKeys: [],\n  minInputs:   1,\n  maxInputs:   Number.MAX_VALUE,\n};\n\nmodule.exports = Gesture;\n\n","'use strict';\n\n/**\n * The Point2D class stores and operates on 2-dimensional points, represented as\n * x and y coordinates.\n *\n * @memberof westures-core\n *\n * @param {number} [ x=0 ] - The x coordinate of the point.\n * @param {number} [ y=0 ] - The y coordinate of the point.\n */\nclass Point2D {\n  constructor(x = 0, y = 0) {\n    /**\n     * The x coordinate of the point.\n     *\n     * @type {number}\n     */\n    this.x = x;\n\n    /**\n     * The y coordinate of the point.\n     *\n     * @type {number}\n     */\n    this.y = y;\n  }\n\n  /**\n   * Calculates the angle between this point and the given point.\n   *\n   * @param {!westures-core.Point2D} point - Projected point for calculating the\n   * angle.\n   *\n   * @return {number} Radians along the unit circle where the projected\n   * point lies.\n   */\n  angleTo(point) {\n    return Math.atan2(point.y - this.y, point.x - this.x);\n  }\n\n  /**\n   * Determine the angle from the centroid to each of the points.\n   *\n   * @param {!westures-core.Point2D[]} points - the Point2D objects to calculate\n   *    the angles to.\n   *\n   * @returns {number[]}\n   */\n  anglesTo(points) {\n    return points.map(point => this.angleTo(point));\n  }\n\n  /**\n   * Determine the average distance from this point to the provided array of\n   * points.\n   *\n   * @param {!westures-core.Point2D[]} points - the Point2D objects to calculate\n   *    the average distance to.\n   *\n   * @return {number} The average distance from this point to the provided\n   *    points.\n   */\n  averageDistanceTo(points) {\n    return this.totalDistanceTo(points) / points.length;\n  }\n\n  /**\n   * Clone this point.\n   *\n   * @return {westures-core.Point2D} A new Point2D, identical to this point.\n   */\n  clone() {\n    return new Point2D(this.x, this.y);\n  }\n\n  /**\n   * Calculates the distance between two points.\n   *\n   * @param {!westures-core.Point2D} point - Point to which the distance is\n   * calculated.\n   *\n   * @return {number} The distance between the two points, a.k.a. the\n   *    hypoteneuse.\n   */\n  distanceTo(point) {\n    return Math.hypot(point.x - this.x, point.y - this.y);\n  }\n\n  /**\n   * Subtract the given point from this point.\n   *\n   * @param {!westures-core.Point2D} point - Point to subtract from this point.\n   *\n   * @return {westures-core.Point2D} A new Point2D, which is the result of (this\n   * - point).\n   */\n  minus(point) {\n    return new Point2D(\n      this.x - point.x,\n      this.y - point.y,\n    );\n  }\n\n  /**\n   * Return the summation of this point to the given point.\n   *\n   * @param {!westures-core.Point2D} point - Point to add to this point.\n   *\n   * @return {westures-core.Point2D} A new Point2D, which is the addition of the\n   * two points.\n   */\n  plus(point) {\n    return new Point2D(\n      this.x + point.x,\n      this.y + point.y,\n    );\n  }\n\n  /**\n   * Calculates the total distance from this point to an array of points.\n   *\n   * @param {!westures-core.Point2D[]} points - The array of Point2D objects to\n   *    calculate the total distance to.\n   *\n   * @return {number} The total distance from this point to the provided points.\n   */\n  totalDistanceTo(points) {\n    return points.reduce((d, p) => d + this.distanceTo(p), 0);\n  }\n\n  /**\n   * Calculates the centroid of a list of points.\n   *\n   * @param {westures-core.Point2D[]} points - The array of Point2D objects for\n   * which to calculate the centroid.\n   *\n   * @return {westures-core.Point2D} The centroid of the provided points.\n   */\n  static centroid(points = []) {\n    if (points.length === 0) return null;\n\n    const total = Point2D.sum(points);\n    total.x /= points.length;\n    total.y /= points.length;\n    return total;\n  }\n\n  /**\n   * Calculates the sum of the given points.\n   *\n   * @param {westures-core.Point2D[]} points - The Point2D objects to sum up.\n   *\n   * @return {westures-core.Point2D} A new Point2D representing the sum of the\n   * given points.\n   */\n  static sum(points = []) {\n    return points.reduce(\n      (total, pt) => {\n        total.x += pt.x;\n        total.y += pt.y;\n        return total;\n      },\n      new Point2D(0, 0),\n    );\n  }\n}\n\nmodule.exports = Point2D;\n\n","'use strict';\n\n/**\n * List of events that trigger the cancel phase.\n *\n * @memberof westures-core\n * @type {string[]}\n */\nconst CANCEL_EVENTS = [\n  'blur',\n  'pointercancel',\n  'touchcancel',\n  'mouseleave',\n];\n\n/**\n * List of keyboard events that trigger a restart.\n *\n * @memberof westures-core\n * @type {string[]}\n */\nconst KEYBOARD_EVENTS = [\n  'keydown',\n  'keyup',\n];\n\n/**\n * List of mouse events to listen to.\n *\n * @memberof westures-core\n * @type {string[]}\n */\nconst MOUSE_EVENTS = [\n  'mousedown',\n  'mousemove',\n  'mouseup',\n];\n\n/**\n * List of pointer events to listen to.\n *\n * @memberof westures-core\n * @type {string[]}\n */\nconst POINTER_EVENTS = [\n  'pointerdown',\n  'pointermove',\n  'pointerup',\n];\n\n/**\n * List of touch events to listen to.\n *\n * @memberof westures-core\n * @type {string[]}\n */\nconst TOUCH_EVENTS = [\n  'touchend',\n  'touchmove',\n  'touchstart',\n];\n\n/**\n * List of potentially state-modifying keys.\n * Entries are: ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'].\n *\n * @memberof westures-core\n * @type {string[]}\n */\nconst STATE_KEYS = [\n  'altKey',\n  'ctrlKey',\n  'metaKey',\n  'shiftKey',\n];\n\n/**\n * List of the 'key' values on KeyboardEvent objects of the potentially\n * state-modifying keys.\n *\n * @memberof westures-core\n * @type {string[]}\n */\nconst STATE_KEY_STRINGS = [\n  'Alt',\n  'Control',\n  'Meta',\n  'Shift',\n];\n\n/**\n * The cancel phase.\n *\n * @memberof westures-core\n * @type {string}\n */\nconst CANCEL = 'cancel';\n\n/**\n * The end phase.\n *\n * @memberof westures-core\n * @type {string}\n */\nconst END = 'end';\n\n/**\n * The move phase.\n *\n * @memberof westures-core\n * @type {string}\n */\nconst MOVE = 'move';\n\n/**\n * The start phase.\n *\n * @memberof westures-core\n * @type {string}\n */\nconst START = 'start';\n\n/**\n * The recognized phases.\n *\n * @memberof westures-core\n * @type {list.<string>}\n */\nconst PHASES = [START, MOVE, END, CANCEL];\n\n/**\n * Object that normalizes the names of window events to be either of type start,\n * move, end, or cancel.\n *\n * @memberof westures-core\n * @type {object}\n */\nconst PHASE = {\n  blur:           CANCEL,\n  pointercancel:  CANCEL,\n  touchcancel:    CANCEL,\n\n  mouseup:       END,\n  pointerup:     END,\n  touchend:      END,\n\n  mousemove:   MOVE,\n  pointermove: MOVE,\n  touchmove:   MOVE,\n\n  mousedown:   START,\n  pointerdown: START,\n  touchstart:  START,\n};\n\nmodule.exports = {\n  CANCEL_EVENTS,\n  KEYBOARD_EVENTS,\n  MOUSE_EVENTS,\n  POINTER_EVENTS,\n  TOUCH_EVENTS,\n\n  STATE_KEYS,\n  STATE_KEY_STRINGS,\n\n  CANCEL,\n  END,\n  MOVE,\n  START,\n\n  PHASE,\n  PHASES,\n};\n\n","'use strict';\n\nconst Point2D   = require('./Point2D.js');\nconst { PHASE } = require('./constants.js');\n\n/**\n * @private\n * @inner\n * @memberof westures-core.PointerData\n *\n * @return {Event} The Event object which corresponds to the given identifier.\n *    Contains clientX, clientY values.\n */\nfunction getEventObject(event, identifier) {\n  if (event.changedTouches) {\n    return Array.from(event.changedTouches).find(touch => {\n      return touch.identifier === identifier;\n    });\n  }\n  return event;\n}\n\n/**\n * Low-level storage of pointer data based on incoming data from an interaction\n * event.\n *\n * @memberof westures-core\n *\n * @param {Event} event - The event object being wrapped.\n * @param {number} identifier - The index of touch if applicable\n */\nclass PointerData {\n  constructor(event, identifier) {\n    const { clientX, clientY } = getEventObject(event, identifier);\n\n    /**\n     * The original event object.\n     *\n     * @type {Event}\n     */\n    this.event = event;\n\n    /**\n     * The type or 'phase' of this batch of pointer data. 'start' or 'move' or\n     * 'end' or 'cancel'\n     *\n     * @type {string}\n     */\n    this.type = PHASE[event.type];\n\n    /**\n     * The timestamp of the event in milliseconds elapsed since January 1, 1970,\n     * 00:00:00 UTC.\n     *\n     * @type {number}\n     */\n    this.time = Date.now();\n\n    /**\n     * The (x,y) coordinate of the event, wrapped in a Point2D.\n     *\n     * @type {westures-core.Point2D}\n     */\n    this.point = new Point2D(clientX, clientY);\n  }\n}\n\nmodule.exports = PointerData;\n\n","'use strict';\n\nconst PI_2   = 2 * Math.PI;\nconst PI_NVE = -Math.PI;\n\n/**\n * Helper function to regulate angular differences, so they don't jump from 0 to\n * 2 * PI or vice versa.\n *\n * @memberof westures-core\n *\n * @param {number} a - Angle in radians.\n * @param {number} b - Angle in radians.\n\n * @return {number} c, given by: c = a - b such that |c| < PI\n */\nfunction angularDifference(a, b) {\n  let diff = a - b;\n  if (diff < PI_NVE) {\n    diff += PI_2;\n  } else if (diff > Math.PI) {\n    diff -= PI_2;\n  }\n  return diff;\n}\n\n/**\n * In case event.composedPath() is not available.\n *\n * @memberof westures-core\n *\n * @param {Event} event\n *\n * @return {Element[]} The elements along the composed path of the event.\n */\nfunction getPropagationPath(event) {\n  if (typeof event.composedPath === 'function') {\n    return event.composedPath();\n  }\n\n  const path = [];\n  for (let node = event.target; node !== document; node = node.parentNode) {\n    path.push(node);\n  }\n  path.push(document);\n  path.push(window);\n\n  return path;\n}\n\n/**\n * Performs a set filter operation.\n *\n * @memberof westures-core\n *\n * @param {Set} set - The set to filter.\n * @param {Function} predicate - Function to test elements of 'set'. Receives\n * one argument: the current set element.\n *\n * @return {Set} Set consisting of elements in 'set' for which 'predicate' is\n * true.\n */\nfunction setFilter(set, predicate) {\n  const result = new Set();\n  set.forEach(element => {\n    if (predicate(element)) {\n      result.add(element);\n    }\n  });\n  return result;\n}\n\n/**\n * Performs a set difference operation.\n *\n * @memberof westures-core\n *\n * @param {Set} left - Base set.\n * @param {Set} right - Set of elements to remove from 'left'.\n *\n * @return {Set} Set consisting of elements in 'left' that are not in\n * 'right'.\n */\nfunction setDifference(left, right) {\n  return setFilter(left, element => !right.has(element));\n}\n\nmodule.exports = {\n  angularDifference,\n  getPropagationPath,\n  setDifference,\n  setFilter,\n};\n\n","'use strict';\n\nconst PointerData = require('./PointerData.js');\nconst { getPropagationPath } = require('./utils.js');\n\n/**\n * Tracks a single input and contains information about the current, previous,\n * and initial events.\n *\n * @memberof westures-core\n *\n * @param {(PointerEvent | MouseEvent | TouchEvent)} event - The input event\n * which will initialize this Input object.\n * @param {number} identifier - The identifier for this input, so that it can\n * be located in subsequent Event objects.\n */\nclass Input {\n  constructor(event, identifier) {\n    const currentData = new PointerData(event, identifier);\n\n    /**\n     * The set of elements along the original event's propagation path at the\n     * time it was dispatched.\n     *\n     * @type {WeakSet.<Element>}\n     */\n    this.initialElements = new WeakSet(getPropagationPath(event));\n\n    /**\n     * Holds the initial data from the mousedown / touchstart / pointerdown that\n     * began this input.\n     *\n     * @type {westures-core.PointerData}\n     */\n    this.initial = currentData;\n\n    /**\n     * Holds the most current pointer data for this Input.\n     *\n     * @type {westures-core.PointerData}\n     */\n    this.current = currentData;\n\n    /**\n     * Holds the previous pointer data for this Input.\n     *\n     * @type {westures-core.PointerData}\n     */\n    this.previous = currentData;\n\n    /**\n     * The identifier for the pointer / touch / mouse button associated with\n     * this input.\n     *\n     * @type {number}\n     */\n    this.identifier = identifier;\n  }\n\n  /**\n   * The phase of the input: 'start' or 'move' or 'end' or 'cancel'\n   *\n   * @type {string}\n   */\n  get phase() { return this.current.type; }\n\n  /**\n   * The timestamp of the initiating event for this input.\n   *\n   * @type {number}\n   */\n  get startTime() { return this.initial.time; }\n\n  /**\n   * The amount of time elapsed between the start of this input and its latest\n   * event.\n   *\n   * @type {number}\n   */\n  get elapsedTime() { return this.current.time - this.initial.time; }\n\n  /**\n   * @return {number} The distance between the initiating event for this input\n   *    and its current event.\n   */\n  totalDistance() {\n    return this.initial.point.distanceTo(this.current.point);\n  }\n\n  /**\n   * Saves the given raw event in PointerData form as the current data for this\n   * input, pushing the old current data into the previous slot, and tossing\n   * out the old previous data.\n   *\n   * @param {Event} event - The event object to wrap with a PointerData.\n   */\n  update(event) {\n    this.previous = this.current;\n    this.current = new PointerData(event, this.identifier);\n  }\n}\n\nmodule.exports = Input;\n\n","'use strict';\n\nconst {\n  CANCEL,\n  END,\n  MOVE,\n  PHASE,\n  START,\n} = require('./constants.js');\nconst Input     = require('./Input.js');\nconst Point2D   = require('./Point2D.js');\n\nconst symbols = {\n  inputs: Symbol.for('inputs'),\n};\n\n/**\n * Set of helper functions for updating inputs based on type of input.\n * Must be called with a bound 'this', via bind(), or call(), or apply().\n *\n * @private\n * @inner\n * @memberof westure-core.State\n */\nconst update_fns = {\n  TouchEvent: function TouchEvent(event) {\n    Array.from(event.changedTouches).forEach(touch => {\n      this.updateInput(event, touch.identifier);\n    });\n  },\n\n  PointerEvent: function PointerEvent(event) {\n    this.updateInput(event, event.pointerId);\n  },\n\n  MouseEvent: function MouseEvent(event) {\n    if (event.button === 0) {\n      this.updateInput(event, event.button);\n    }\n  },\n};\n\n/**\n * Keeps track of currently active and ending input points on the interactive\n * surface.\n *\n * @memberof westures-core\n *\n * @param {Element} element - The element underpinning the associated Region.\n */\nclass State {\n  constructor(element) {\n    /**\n     * Keep a reference to the element for the associated region.\n     *\n     * @type {Element}\n     */\n    this.element = element;\n\n    /**\n     * Keeps track of the current Input objects.\n     *\n     * @alias [@@inputs]\n     * @type {Map.<westures-core.Input>}\n     * @memberof westure-core.State\n     */\n    this[symbols.inputs] = new Map();\n\n    /**\n     * All currently valid inputs, including those that have ended.\n     *\n     * @type {westures-core.Input[]}\n     */\n    this.inputs = [];\n\n    /**\n     * The array of currently active inputs, sourced from the current Input\n     * objects. \"Active\" is defined as not being in the 'end' phase.\n     *\n     * @type {westures-core.Input[]}\n     */\n    this.active = [];\n\n    /**\n     * The array of latest point data for the currently active inputs, sourced\n     * from this.active.\n     *\n     * @type {westures-core.Point2D[]}\n     */\n    this.activePoints = [];\n\n    /**\n     * The centroid of the currently active points.\n     *\n     * @type {westures-core.Point2D}\n     */\n    this.centroid = {};\n\n    /**\n     * The latest event that the state processed.\n     *\n     * @type {Event}\n     */\n    this.event = null;\n  }\n\n  /**\n   * Deletes all inputs that are in the 'end' phase.\n   */\n  clearEndedInputs() {\n    this[symbols.inputs].forEach((v, k) => {\n      if (v.phase === 'end') this[symbols.inputs].delete(k);\n    });\n  }\n\n  /**\n   * @param {string} phase - One of 'start', 'move', 'end', or 'cancel'.\n   *\n   * @return {westures-core.Input[]} Inputs in the given phase.\n   */\n  getInputsInPhase(phase) {\n    return this.inputs.filter(i => i.phase === phase);\n  }\n\n  /**\n   * @param {string} phase - One of 'start', 'move', 'end', or 'cancel'.\n   *\n   * @return {westures-core.Input[]} Inputs <b>not</b> in the given phase.\n   */\n  getInputsNotInPhase(phase) {\n    return this.inputs.filter(i => i.phase !== phase);\n  }\n\n  /**\n   * @return {boolean} True if there are no active inputs. False otherwise.\n   */\n  hasNoInputs() {\n    return this[symbols.inputs].size === 0;\n  }\n\n  /**\n   * Update the input with the given identifier using the given event.\n   *\n   * @private\n   *\n   * @param {Event} event - The event being captured.\n   * @param {number} identifier - The identifier of the input to update.\n   */\n  updateInput(event, identifier) {\n    switch (PHASE[event.type]) {\n    case START:\n      this[symbols.inputs].set(\n        identifier,\n        new Input(event, identifier),\n      );\n      try {\n        this.element.setPointerCapture(identifier);\n      } catch (e) {\n        // NOP: Optional operation failed.\n      }\n      break;\n\n    // All of 'end', 'move', and 'cancel' perform updates, hence the\n    // following fall-throughs\n    case END:\n      try {\n        this.element.releasePointerCapture(identifier);\n      } catch (e) {\n        // NOP: Optional operation failed.\n      }\n    case CANCEL:\n    case MOVE:\n      if (this[symbols.inputs].has(identifier)) {\n        this[symbols.inputs].get(identifier).update(event);\n      }\n      break;\n\n    default:\n      console.warn(`Unrecognized event type: ${event.type}`);\n    }\n  }\n\n  /**\n   * Updates the inputs with new information based upon a new event being fired.\n   *\n   * @private\n   * @param {Event} event - The event being captured.\n   */\n  updateAllInputs(event) {\n    update_fns[event.constructor.name].call(this, event);\n    this.updateFields(event);\n  }\n\n  /**\n   * Updates the convenience fields.\n   *\n   * @private\n   * @param {Event} event - Event with which to update the convenience fields.\n   */\n  updateFields(event) {\n    this.inputs = Array.from(this[symbols.inputs].values());\n    this.active = this.getInputsNotInPhase('end');\n    this.activePoints = this.active.map(i => i.current.point);\n    this.centroid = Point2D.centroid(this.activePoints);\n    this.event = event;\n  }\n}\n\nmodule.exports = State;\n\n","'use strict';\n\nconst State = require('./State.js');\nconst {\n  CANCEL_EVENTS,\n  KEYBOARD_EVENTS,\n  MOUSE_EVENTS,\n  POINTER_EVENTS,\n  TOUCH_EVENTS,\n\n  STATE_KEY_STRINGS,\n\n  PHASE,\n\n  CANCEL,\n  END,\n  START,\n} = require('./constants.js');\nconst {\n  setDifference,\n  setFilter,\n} = require('./utils.js');\n\n/**\n * Allows the user to specify the control region which will listen for user\n * input events.\n *\n * @memberof westures-core\n *\n * @param {Element} element=window - The element which should listen to input\n * events.\n * @param {object} [options]\n * @param {boolean} [options.capture=false] - Whether the region uses the\n * capture phase of input events. If false, uses the bubbling phase.\n * @param {boolean} [options.preferPointer=true] - If false, the region listens\n * to mouse/touch events instead of pointer events.\n * @param {boolean} [options.preventDefault=true] - Whether the default\n * browser functionality should be disabled. This option should most likely be\n * ignored. Here there by dragons if set to false.\n * @param {string} [options.touchAction='none'] - Value to set the CSS\n * 'touch-action' property to on elements added to the region.\n */\nclass Region {\n  constructor(element = window, options = {}) {\n    options = { ...Region.DEFAULTS, ...options };\n\n    /**\n     * The list of relations between elements, their gestures, and the handlers.\n     *\n     * @type {Set.<westures-core.Gesture>}\n     */\n    this.gestures = new Set();\n\n    /**\n     * The list of active gestures for the current input session.\n     *\n     * @type {Set.<westures-core.Gesture>}\n     */\n    this.activeGestures = new Set();\n\n    /**\n     * The base list of potentially active gestures for the current input\n     * session.\n     *\n     * @type {Set.<westures-core.Gesture>}\n     */\n    this.potentialGestures = new Set();\n\n    /**\n     * The element being bound to.\n     *\n     * @type {Element}\n     */\n    this.element = element;\n\n    /**\n     * The user-supplied options for the Region.\n     *\n     * @type {object}\n     */\n    this.options = options;\n\n    /**\n     * The internal state object for a Region.  Keeps track of inputs.\n     *\n     * @type {westures-core.State}\n     */\n    this.state = new State(this.element);\n\n    // Begin operating immediately.\n    this.activate();\n  }\n\n  /**\n   * Activates the region by adding event listeners for all appropriate input\n   * events to the region's element.\n   *\n   * @private\n   */\n  activate() {\n    /*\n     * Listening to both mouse and touch comes with the difficulty that\n     * preventDefault() must be called to prevent both events from iterating\n     * through the system. However I have left it as an option to the end user,\n     * which defaults to calling preventDefault(), in case there's a use-case I\n     * haven't considered or am not aware of.\n     *\n     * It also may be a good idea to keep regions small in large pages.\n     *\n     * See:\n     *  https://www.html5rocks.com/en/mobile/touchandmouse/\n     *  https://developer.mozilla.org/en-US/docs/Web/API/Touch_events\n     *  https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events\n     */\n    let eventNames = [];\n    if (this.options.preferPointer && window.PointerEvent) {\n      eventNames = POINTER_EVENTS;\n    } else {\n      eventNames = MOUSE_EVENTS.concat(TOUCH_EVENTS);\n    }\n\n    // Bind detected browser events to the region element.\n    const arbitrate = this.arbitrate.bind(this);\n    eventNames.forEach(eventName => {\n      this.element.addEventListener(eventName, arbitrate, {\n        capture: this.options.capture,\n        once:    false,\n        passive: false,\n      });\n    });\n\n    const cancel = this.cancel.bind(this);\n    CANCEL_EVENTS.forEach(eventName => {\n      window.addEventListener(eventName, cancel);\n    });\n\n    const handleKeyboardEvent = this.handleKeyboardEvent.bind(this);\n    KEYBOARD_EVENTS.forEach(eventName => {\n      window.addEventListener(eventName, handleKeyboardEvent);\n    });\n  }\n\n  /**\n   * Handles a cancel event. Resets the state and the active / potential gesture\n   * lists.\n   *\n   * @private\n   * @param {Event} event - The event emitted from the window object.\n   */\n  cancel(event) {\n    if (this.options.preventDefault) event.preventDefault();\n    this.state.inputs.forEach(input => {\n      input.update(event);\n    });\n    this.activeGestures.forEach(gesture => {\n      gesture.evaluateHook(CANCEL, this.state);\n    });\n    this.state = new State(this.element);\n    this.resetActiveGestures();\n  }\n\n  /**\n   * Handles a keyboard event, triggering a restart of any gestures that need\n   * it.\n   *\n   * @private\n   * @param {KeyboardEvent} event - The keyboard event.\n   */\n  handleKeyboardEvent(event) {\n    if (STATE_KEY_STRINGS.indexOf(event.key) >= 0) {\n      this.state.event = event;\n      const oldActiveGestures = this.activeGestures;\n      this.setActiveGestures();\n\n      setDifference(oldActiveGestures, this.activeGestures).forEach(gesture => {\n        gesture.evaluateHook(END, this.state);\n      });\n      setDifference(this.activeGestures, oldActiveGestures).forEach(gesture => {\n        gesture.evaluateHook(START, this.state);\n      });\n    }\n  }\n\n  /**\n   * Resets the active gestures.\n   *\n   * @private\n   */\n  resetActiveGestures() {\n    this.potentialGestures = new Set();\n    this.activeGestures = new Set();\n  }\n\n  /**\n   * Selects active gestures from the list of potentially active gestures.\n   *\n   * @private\n   */\n  setActiveGestures() {\n    this.activeGestures = setFilter(this.potentialGestures, gesture => {\n      return gesture.isEnabled(this.state);\n    });\n  }\n\n  /**\n   * Selects the potentially active gestures.\n   *\n   * @private\n   */\n  setPotentialGestures() {\n    const input = this.state.inputs[0];\n    this.potentialGestures = setFilter(this.gestures, gesture => {\n      return input.initialElements.has(gesture.element);\n    });\n  }\n\n  /**\n   * Selects the gestures that are active for the current input sequence.\n   *\n   * @private\n   * @param {Event} event - The event emitted from the window object.\n   * @param {boolean} isInitial - Whether this is an initial contact.\n   */\n  updateActiveGestures(event, isInitial) {\n    if (PHASE[event.type] === START) {\n      if (isInitial) {\n        this.setPotentialGestures();\n      }\n      this.setActiveGestures();\n    }\n  }\n\n  /**\n   * Evaluates whether the current input session has completed.\n   *\n   * @private\n   * @param {Event} event - The event emitted from the window object.\n   */\n  pruneActiveGestures(event) {\n    if (PHASE[event.type] === END) {\n      if (this.state.hasNoInputs()) {\n        this.resetActiveGestures();\n      } else {\n        this.setActiveGestures();\n      }\n    }\n  }\n\n  /**\n   * All input events flow through this function. It makes sure that the input\n   * state is maintained, determines which gestures to analyze based on the\n   * initial position of the inputs, calls the relevant gesture hooks, and\n   * dispatches gesture data.\n   *\n   * @private\n   * @param {Event} event - The event emitted from the window object.\n   */\n  arbitrate(event) {\n    const isInitial = this.state.hasNoInputs();\n    this.state.updateAllInputs(event);\n    this.updateActiveGestures(event, isInitial);\n\n    if (this.activeGestures.size > 0) {\n      if (this.options.preventDefault) event.preventDefault();\n\n      this.activeGestures.forEach(gesture => {\n        gesture.evaluateHook(PHASE[event.type], this.state);\n      });\n    }\n\n    this.state.clearEndedInputs();\n    this.pruneActiveGestures(event);\n  }\n\n  /**\n   * Adds the given gesture to the region.\n   *\n   * @param {westures-core.Gesture} gesture - Instantiated gesture to add.\n   */\n  addGesture(gesture) {\n    gesture.element.style.touchAction = this.options.touchAction;\n    this.gestures.add(gesture);\n  }\n\n  /**\n   * Removes the given gesture from the region.\n   *\n   * @param {westures-core.Gesture} gesture - Instantiated gesture to add.\n   */\n  removeGesture(gesture) {\n    this.gestures.delete(gesture);\n    this.potentialGestures.delete(gesture);\n    this.activeGestures.delete(gesture);\n  }\n\n  /**\n   * Retrieves Gestures by their associated element.\n   *\n   * @param {Element} element - The element for which to find gestures.\n   *\n   * @return {westures-core.Gesture[]} Gestures to which the element is bound.\n   */\n  getGesturesByElement(element) {\n    return setFilter(this.gestures, gesture => gesture.element === element);\n  }\n\n  /**\n   * Remove all gestures bound to the given element.\n   *\n   * @param {Element} element - The element to unbind.\n   */\n  removeGesturesByElement(element) {\n    this.getGesturesByElement(element).forEach(g => this.removeGesture(g));\n  }\n}\n\nRegion.DEFAULTS = {\n  capture:        false,\n  preferPointer:  true,\n  preventDefault: true,\n  touchAction:    'none',\n};\n\nmodule.exports = Region;\n","'use strict';\n\nconst cascade = Symbol('cascade');\nconst smooth = Symbol('smooth');\n\n/**\n * Determines whether to apply smoothing. Smoothing is on by default but turned\n * off if either:<br>\n *  1. The user explicitly requests that it be turned off.<br>\n *  2. The active pointer is not \"coarse\".<br>\n *\n * @see {@link\n * https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia}\n *\n * @inner\n * @memberof westures-core.Smoothable\n *\n * @param {boolean} isRequested - Whether smoothing was requested by the user.\n *\n * @returns {boolean} Whether to apply smoothing.\n */\nfunction smoothingIsApplicable(isRequested) {\n  if (isRequested) {\n    try {\n      return window.matchMedia('(pointer: coarse)').matches;\n    } catch (e) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * A Smoothable datatype is one that is capable of smoothing out a series of\n * values as they come in, one at a time, providing a more consistent series. It\n * does this by creating some inertia in the values using a cascading average.\n * (For those who are interested in such things, this effectively means that it\n * provides a practical application of Zeno's Dichotomy).\n *\n * @example\n * const x = new Smoothable({ identity: 1 });\n * const a = x.next(1);   // 1.0\n * const b = x.next(1.2); // 1.1\n * const c = x.next(0.9); // 1.0\n * const d = x.next(0.6); // 0.8\n * const e = x.next(1.2); // 1.0\n * const f = x.next(1.6); // 1.3\n * x.restart();\n * const g = x.next(0);   // 0.5\n *\n * @memberof westures-core\n *\n * @param {Object} [options]\n * @param {boolean} [options.applySmoothing=true] Whether to apply smoothing to\n * the data.\n * @param {*} [options.identity=0] The identity value of this smoothable data.\n */\nclass Smoothable {\n  constructor(options = {}) {\n    const final_options = { ...Smoothable.DEFAULTS, ...options };\n\n    /**\n     * The function through which smoothed emits are passed.\n     *\n     * @method\n     * @param {*} data - The data to emit.\n     *\n     * @return {*} The smoothed out data.\n     */\n    this.next = null;\n    if (smoothingIsApplicable(final_options.applySmoothing)) {\n      this.next = this[smooth].bind(this);\n    } else {\n      this.next = data => data;\n    }\n\n    /**\n     * The \"identity\" value of the data that will be smoothed.\n     *\n     * @type {*}\n     * @default 0\n     */\n    this.identity = final_options.identity;\n\n    /**\n     * The cascading average of outgoing values.\n     *\n     * @memberof westures-core.Smoothable\n     * @alias [@@cascade]\n     * @type {object}\n     */\n    this[cascade] = this.identity;\n  }\n\n  /**\n   * Restart the Smoothable gesture.\n   */\n  restart() {\n    this[cascade] = this.identity;\n  }\n\n  /**\n   * Smooth out the outgoing data.\n   *\n   * @memberof westures-core.Smoothable\n   * @alias [@@smooth]\n   * @param {object} data - The next batch of data to emit.\n   *\n   * @return {?object}\n   */\n  [smooth](data) {\n    const average = this.average(this[cascade], data);\n    this[cascade] = average;\n    return average;\n  }\n\n  /**\n   * Average out two values, as part of the smoothing algorithm. Override this\n   * method if the data being smoothed is not a Number.\n   *\n   * @param {number} a\n   * @param {number} b\n   *\n   * @return {number} The average of 'a' and 'b'\n   */\n  average(a, b) {\n    return (a + b) / 2;\n  }\n}\n\nSmoothable.DEFAULTS = {\n  applySmoothing: true,\n  identity:       0,\n};\n\nmodule.exports = Smoothable;\n\n","/*\n * Contains the Pan class.\n */\n\n'use strict';\n\nconst { Gesture, Point2D, Smoothable } = require('../core');\n\n/**\n * Data returned when a Pan is recognized.\n *\n * @typedef {Object} PanData\n * @mixes ReturnTypes.BaseData\n *\n * @property {westures-core.Point2D} translation - The change vector from the\n * last emit.\n *\n * @memberof ReturnTypes\n */\n\n/**\n * A Pan is defined as a normal movement in any direction.\n *\n * @extends westures-core.Gesture\n * @see {ReturnTypes.PanData}\n * @see {westures-core.Smoothable}\n * @memberof westures\n *\n * @param {Element} element - The element with which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n * is recognized on the associated element.\n * @param {object} [options] - Gesture customization options.\n * @param {westures-core.STATE_KEYS[]} [options.enableKeys=[]] - List of keys\n * which will enable the gesture. The gesture will not be recognized unless one\n * of these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the enable key is always down.\n * @param {westures-core.STATE_KEYS[]} [options.disableKeys=[]] - List of keys\n * which will disable the gesture. The gesture will not be recognized if one of\n * these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the disable key is never down.\n * @param {number} [options.minInputs=1] - The minimum number of pointers that\n * must be active for the gesture to be recognized. Uses >=.\n * @param {number} [options.maxInputs=Number.MAX_VALUE] - The maximum number of\n * pointers that may be active for the gesture to be recognized. Uses <=.\n * @param {boolean} [options.applySmoothing=true] - Whether to apply inertial\n * smoothing for systems with coarse pointers.\n */\nclass Pan extends Gesture {\n  constructor(element, handler, options = {}) {\n    super('pan', element, handler, options);\n\n    /**\n     * The previous point location.\n     *\n     * @type {westures-core.Point2D}\n     */\n    this.previous = null;\n\n    /*\n     * The outgoing data, with optional inertial smoothing.\n     *\n     * @override\n     * @type {westures-core.Smoothable<westures-core.Point2D>}\n     */\n    this.outgoing = new Smoothable({ ...options, identity: new Point2D() });\n    this.outgoing.average = (a, b) => Point2D.centroid([a, b]);\n  }\n\n  /**\n   * Resets the gesture's progress by saving the current centroid of the active\n   * inputs. To be called whenever the number of inputs changes.\n   *\n   * @param {State} state\n   */\n  restart(state) {\n    this.previous = state.centroid;\n    this.outgoing.restart();\n  }\n\n  start(state) {\n    this.restart(state);\n  }\n\n  move(state) {\n    const translation = state.centroid.minus(this.previous);\n    this.previous = state.centroid;\n    return { translation: this.outgoing.next(translation) };\n  }\n\n  end(state) {\n    this.restart(state);\n  }\n\n  cancel(state) {\n    this.restart(state);\n  }\n}\n\nmodule.exports = Pan;\n\n","/**\n * The global API interface for westures-core. Exposes all classes, constants,\n * and routines used by the package. Use responsibly.\n *\n * @namespace westures-core\n */\n\n'use strict';\n\nconst Gesture = require('./src/Gesture.js');\nconst Input = require('./src/Input.js');\nconst Point2D = require('./src/Point2D.js');\nconst PointerData = require('./src/PointerData.js');\nconst Region = require('./src/Region.js');\nconst Smoothable = require('./src/Smoothable.js');\nconst State = require('./src/State.js');\nconst constants = require('./src/constants.js');\nconst utils = require('./src/utils.js');\n\nmodule.exports = {\n  Gesture,\n  Input,\n  Point2D,\n  PointerData,\n  Region,\n  Smoothable,\n  State,\n  ...constants,\n  ...utils,\n};\n\n","/*\n * Contains the abstract Pinch class.\n */\n\n'use strict';\n\nconst { Gesture, Smoothable } = require('../core');\n\n/**\n * Data returned when a Pinch is recognized.\n *\n * @typedef {Object} PinchData\n * @mixes ReturnTypes.BaseData\n *\n * @property {number} distance - The average distance from an active input to\n *    the centroid.\n * @property {number} scale - The proportional change in distance since last\n * emit.\n *\n * @memberof ReturnTypes\n */\n\n/**\n * A Pinch is defined as two or more inputs moving either together or apart.\n *\n * @extends westures-core.Gesture\n * @see {ReturnTypes.PinchData}\n * @memberof westures\n *\n * @param {Element} element - The element to which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n * is recognized on the associated element.\n * @param {object} [options] - Gesture customization options.\n * @param {westures-core.STATE_KEYS[]} [options.enableKeys=[]] - List of keys\n * which will enable the gesture. The gesture will not be recognized unless one\n * of these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the enable key is always down.\n * @param {westures-core.STATE_KEYS[]} [options.disableKeys=[]] - List of keys\n * which will disable the gesture. The gesture will not be recognized if one of\n * these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the disable key is never down.\n * @param {number} [options.minInputs=2] - The minimum number of pointers that\n * must be active for the gesture to be recognized. Uses >=.\n * @param {number} [options.maxInputs=Number.MAX_VALUE] - The maximum number of\n * pointers that may be active for the gesture to be recognized. Uses <=.\n * @param {boolean} [options.applySmoothing=true] - Whether to apply inertial\n * smoothing for systems with coarse pointers.\n */\nclass Pinch extends Gesture {\n  constructor(element, handler, options = {}) {\n    options = { ...Pinch.DEFAULTS, ...options };\n    super('pinch', element, handler, options);\n\n    /**\n     * The previous distance.\n     *\n     * @type {number}\n     */\n    this.previous = 0;\n\n    /*\n     * The outgoing data, with optional inertial smoothing.\n     *\n     * @override\n     * @type {westures-core.Smoothable<number>}\n     */\n    this.outgoing = new Smoothable({ ...options, identity: 1 });\n  }\n\n  /**\n   * Initializes the gesture progress.\n   *\n   * @param {State} state - current input state.\n   */\n  restart(state) {\n    this.previous = state.centroid.averageDistanceTo(state.activePoints);\n    this.outgoing.restart();\n  }\n\n  start(state) {\n    this.restart(state);\n  }\n\n  move(state) {\n    const distance = state.centroid.averageDistanceTo(state.activePoints);\n    const scale = distance / this.previous;\n    this.previous = distance;\n    return { distance, scale: this.outgoing.next(scale) };\n  }\n\n  end(state) {\n    this.restart(state);\n  }\n\n  cancel(state) {\n    this.restart(state);\n  }\n}\n\nPinch.DEFAULTS = Object.freeze({\n  minInputs: 2,\n});\n\nmodule.exports = Pinch;\n\n","/*\n * Contains the Press class.\n */\n\n'use strict';\n\nconst { Gesture, Point2D, MOVE } = require('../core');\n\n/**\n * Data returned when a Press is recognized.\n *\n * @typedef {Object} PressData\n *\n * @property {westures-core.Point2D} centroid - The current centroid of the\n * input points.\n * @property {westures-core.Point2D} initial - The initial centroid of the input\n * points.\n * @property {number} distance - The total movement since initial contact.\n *\n * @memberof ReturnTypes\n */\n\n/**\n * A Press is defined as one or more input points being held down without\n * moving. Press gestures may be stacked by pressing with additional pointers\n * beyond the minimum, so long as none of the points move or are lifted, a Press\n * will be recognized for each additional pointer.\n *\n * @extends westures-core.Gesture\n * @see {ReturnTypes.PressData}\n * @memberof westures\n *\n * @param {Element} element - The element to which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n * is recognized on the associated element.\n * @param {object} [options] - Gesture customization options.\n * @param {westures-core.STATE_KEYS[]} [options.enableKeys=[]] - List of keys\n * which will enable the gesture. The gesture will not be recognized unless one\n * of these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the enable key is always down.\n * @param {westures-core.STATE_KEYS[]} [options.disableKeys=[]] - List of keys\n * which will disable the gesture. The gesture will not be recognized if one of\n * these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the disable key is never down.\n * @param {number} [options.minInputs=1] - The minimum number of pointers that\n * must be active for the gesture to be recognized. Uses >=.\n * @param {number} [options.maxInputs=Number.MAX_VALUE] - The maximum number of\n * pointers that may be active for the gesture to be recognized. Uses <=.\n * @param {number} [options.delay=1000] - The delay before emitting, during\n * which time the number of inputs must not go below minInputs.\n * @param {number} [options.tolerance=10] - The tolerance in pixels a user can\n * move and still allow the gesture to emit.\n */\nclass Press extends Gesture {\n  constructor(element, handler, options = {}) {\n    super('press', element, handler, { ...Press.DEFAULTS, ...options });\n  }\n\n  start(state) {\n    const initial = state.centroid;\n    const originalInputs = Array.from(state.active);\n    setTimeout(() => {\n      const inputs = state.active.filter(i => originalInputs.includes(i));\n      if (inputs.length === originalInputs.length) {\n        const centroid = Point2D.centroid(inputs.map(i => i.current.point));\n        const distance = initial.distanceTo(centroid);\n        if (distance <= this.options.tolerance) {\n          this.recognize(MOVE, state, { centroid, distance, initial });\n        }\n      }\n    }, this.options.delay);\n  }\n}\n\nPress.DEFAULTS = Object.freeze({\n  delay:     1000,\n  tolerance: 10,\n});\n\nmodule.exports = Press;\n\n","/*\n * Contains the abstract Pull class.\n */\n\n'use strict';\n\nconst { Smoothable } = require('../core');\nconst Pivotable = require('./Pivotable.js');\n\n/**\n * Data returned when a Pull is recognized.\n *\n * @typedef {Object} PullData\n * @mixes ReturnTypes.BaseData\n *\n * @property {number} distance - The average distance from an active input to\n * the centroid.\n * @property {number} scale - The proportional change in distance since last\n * emit.\n * @property {westures-core.Point2D} pivot - The pivot point.\n *\n * @memberof ReturnTypes\n */\n\n/**\n * A Pull is defined as a single input moving away from or towards a pivot\n * point.\n *\n * @extends westures-core.Gesture\n * @see {ReturnTypes.PullData}\n * @memberof westures\n *\n * @param {Element} element - The element to which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n * is recognized on the associated element.\n * @param {object} [options] - Gesture customization options.\n * @param {westures-core.STATE_KEYS[]} [options.enableKeys=[]] - List of keys\n * which will enable the gesture. The gesture will not be recognized unless one\n * of these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the enable key is always down.\n * @param {westures-core.STATE_KEYS[]} [options.disableKeys=[]] - List of keys\n * which will disable the gesture. The gesture will not be recognized if one of\n * these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the disable key is never down.\n * @param {number} [options.minInputs=1] - The minimum number of pointers that\n * must be active for the gesture to be recognized. Uses >=.\n * @param {number} [options.maxInputs=Number.MAX_VALUE] - The maximum number of\n * pointers that may be active for the gesture to be recognized. Uses <=.\n * @param {boolean} [options.applySmoothing=true] - Whether to apply inertial\n * smoothing for systems with coarse pointers.\n * @param {number} [options.deadzoneRadius=15] - The radius in pixels around the\n * start point in which to do nothing.\n * @param {Element} [options.dynamicPivot=false] - Normally the center point of\n * the gesture's element is used as the pivot. If this option is set, the\n * initial contact point with the element is used as the pivot instead.\n */\nclass Pull extends Pivotable {\n  constructor(element, handler, options = {}) {\n    super('pull', element, handler, options);\n\n    /*\n     * The outgoing data, with optional inertial smoothing.\n     *\n     * @override\n     * @type {westures-core.Smoothable<number>}\n     */\n    this.outgoing = new Smoothable({ ...options, identity: 1 });\n  }\n\n  updatePrevious(state) {\n    this.previous = this.pivot.distanceTo(state.centroid);\n  }\n\n  move(state) {\n    const pivot = this.pivot;\n    const distance = pivot.distanceTo(state.centroid);\n    const scale = distance / this.previous;\n    const { deadzoneRadius } = this.options;\n\n    let rv = null;\n    if (distance > deadzoneRadius && this.previous > deadzoneRadius) {\n      rv = { distance, scale: this.outgoing.next(scale), pivot };\n    }\n\n    /*\n     * Updating the previous distance regardless of emit prevents sudden changes\n     * when the user exits the deadzone circle.\n     */\n    this.previous = distance;\n\n    return rv;\n  }\n}\n\nmodule.exports = Pull;\n\n","/*\n * Contains the Rotate class.\n */\n\n'use strict';\n\nconst { Gesture, Point2D, Smoothable } = require('../core');\n\n/**\n * Data returned when a Pivotable is recognized.\n *\n * @typedef {Object} SwivelData\n * @mixes ReturnTypes.BaseData\n *\n * @property {number} rotation - In radians, the change in angle since last\n * emit.\n * @property {westures-core.Point2D} pivot - The pivot point.\n *\n * @memberof ReturnTypes\n */\n\n/**\n * A Pivotable is a single input rotating around a fixed point. The fixed point\n * is determined by the input's location at its 'start' phase.\n *\n * @extends westures.Gesture\n * @see {ReturnTypes.SwivelData}\n * @memberof westures\n *\n * @param {Element} element - The element to which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n * is recognized on the associated element.\n * @param {object} [options] - Gesture customization options.\n * @param {westures-core.STATE_KEYS[]} [options.enableKeys=[]] - List of keys\n * which will enable the gesture. The gesture will not be recognized unless one\n * of these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the enable key is always down.\n * @param {westures-core.STATE_KEYS[]} [options.disableKeys=[]] - List of keys\n * which will disable the gesture. The gesture will not be recognized if one of\n * these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the disable key is never down.\n * @param {number} [options.minInputs=1] - The minimum number of pointers that\n * must be active for the gesture to be recognized. Uses >=.\n * @param {number} [options.maxInputs=Number.MAX_VALUE] - The maximum number of\n * pointers that may be active for the gesture to be recognized. Uses <=.\n * @param {boolean} [options.applySmoothing=true] - Whether to apply inertial\n * smoothing for systems with coarse pointers.\n * @param {number} [options.deadzoneRadius=15] - The radius in pixels around the\n * start point in which to do nothing.\n * @param {Element} [options.dynamicPivot=false] - Normally the center point of\n * the gesture's element is used as the pivot. If this option is set, the\n * initial contact point with the element is used as the pivot instead.\n */\nclass Pivotable extends Gesture {\n  constructor(type = 'pivotable', element, handler, options = {}) {\n    super(type, element, handler, { ...Pivotable.DEFAULTS, ...options });\n\n    /**\n     * The pivot point of the pivotable.\n     *\n     * @type {westures-core.Point2D}\n     */\n    this.pivot = null;\n\n    /**\n     * The previous data.\n     *\n     * @type {number}\n     */\n    this.previous = 0;\n\n    /**\n     * The outgoing data.\n     *\n     * @type {westures-core.Smoothable}\n     */\n    this.outgoing = new Smoothable(options);\n  }\n\n  /**\n   * Determine the center point of the given element's bounding client\n   * rectangle.\n   *\n   * @static\n   *\n   * @param {Element} element - The DOM element to analyze.\n   * @return {westures-core.Point2D} - The center of the element's bounding\n   * client rectangle.\n   */\n  static getClientCenter(element) {\n    const rect = element.getBoundingClientRect();\n    return new Point2D(\n      rect.left + (rect.width / 2),\n      rect.top + (rect.height / 2),\n    );\n  }\n\n  /**\n   * Updates the previous data. It will be called during the 'start' and 'end'\n   * phases, and should also be called during the 'move' phase implemented by\n   * the subclass.\n   *\n   * @abstract\n   * @param {State} state - the current input state.\n   */\n  updatePrevious() {\n    throw 'Gestures which extend Pivotable must implement updatePrevious()';\n  }\n\n  /**\n   * Restart the given progress object using the given input object.\n   *\n   * @param {State} state - current input state.\n   */\n  restart(state) {\n    if (this.options.dynamicPivot) {\n      this.pivot = state.centroid;\n      this.previous = 0;\n    } else {\n      this.pivot = Pivotable.getClientCenter(this.element);\n      this.updatePrevious(state);\n    }\n    this.outgoing.restart();\n  }\n\n  start(state) {\n    this.restart(state);\n  }\n\n  end(state) {\n    if (state.active.length > 0) {\n      this.restart(state);\n    } else {\n      this.outgoing.restart();\n    }\n  }\n\n  cancel() {\n    this.outgoing.restart();\n  }\n}\n\nPivotable.DEFAULTS = Object.freeze({\n  deadzoneRadius: 15,\n  dynamicPivot:   false,\n});\n\nmodule.exports = Pivotable;\n","/*\n * Contains the Rotate class.\n */\n\n'use strict';\n\nconst { angularDifference, Gesture, Smoothable } = require('../core');\n\n/**\n * Data returned when a Rotate is recognized.\n *\n * @typedef {Object} RotateData\n * @mixes ReturnTypes.BaseData\n *\n * @property {number} rotation - In radians, the change in angle since last\n * emit.\n *\n * @memberof ReturnTypes\n */\n\n/**\n * A Rotate is defined as two inputs moving with a changing angle between them.\n *\n * @extends westures-core.Gesture\n * @see {ReturnTypes.RotateData}\n * @memberof westures\n *\n * @param {Element} element - The element to which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n * is recognized on the associated element.\n * @param {object} [options] - Gesture customization options.\n * @param {westures-core.STATE_KEYS[]} [options.enableKeys=[]] - List of keys\n * which will enable the gesture. The gesture will not be recognized unless one\n * of these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the enable key is always down.\n * @param {westures-core.STATE_KEYS[]} [options.disableKeys=[]] - List of keys\n * which will disable the gesture. The gesture will not be recognized if one of\n * these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the disable key is never down.\n * @param {number} [options.minInputs=2] - The minimum number of pointers that\n * must be active for the gesture to be recognized. Uses >=.\n * @param {number} [options.maxInputs=Number.MAX_VALUE] - The maximum number of\n * pointers that may be active for the gesture to be recognized. Uses <=.\n * @param {boolean} [options.applySmoothing=true] - Whether to apply inertial\n * smoothing for systems with coarse pointers.\n */\nclass Rotate extends Gesture {\n  constructor(element, handler, options = {}) {\n    options = { ...Rotate.DEFAULTS, ...options };\n    super('rotate', element, handler, options);\n\n    /**\n     * Track the previous angles for each input.\n     *\n     * @type {number[]}\n     */\n    this.previousAngles = [];\n\n    /*\n     * The outgoing data, with optional inertial smoothing.\n     *\n     * @override\n     * @type {westures-core.Smoothable<number>}\n     */\n    this.outgoing = new Smoothable(options);\n  }\n\n  /**\n   * Restart the gesture for a new number of inputs.\n   *\n   * @param {State} state - current input state.\n   */\n  restart(state) {\n    this.previousAngles = state.centroid.anglesTo(state.activePoints);\n    this.outgoing.restart();\n  }\n\n  start(state) {\n    this.restart(state);\n  }\n\n  move(state) {\n    const stagedAngles = state.centroid.anglesTo(state.activePoints);\n    const angle = stagedAngles.reduce((total, current, index) => {\n      return total + angularDifference(current, this.previousAngles[index]);\n    }, 0);\n    this.previousAngles = stagedAngles;\n    const rotation = angle / state.activePoints.length;\n    return { rotation: this.outgoing.next(rotation) };\n  }\n\n  end(state) {\n    this.restart(state);\n  }\n\n  cancel() {\n    this.outgoing.restart();\n  }\n}\n\nRotate.DEFAULTS = Object.freeze({\n  minInputs: 2,\n});\n\nmodule.exports = Rotate;\n\n","/*\n * Contains the Swipe class.\n */\n\n'use strict';\n\nconst { Gesture } = require('../core');\n\nconst PROGRESS_STACK_SIZE = 7;\nconst MS_THRESHOLD = 300;\n\n/**\n * Data returned when a Swipe is recognized.\n *\n * @typedef {Object} SwipeData\n * @mixes ReturnTypes.BaseData\n *\n * @property {number} velocity - The velocity of the swipe.\n * @property {number} direction - In radians, the direction of the swipe.\n * @property {westures-core.Point2D} point - The point at which the swipe ended.\n * @property {number} time - The epoch time, in ms, when the swipe ended.\n *\n * @memberof ReturnTypes\n */\n\n/**\n * A swipe is defined as input(s) moving in the same direction in an relatively\n * increasing velocity and leaving the screen at some point before it drops\n * below it's escape velocity.\n *\n * @extends westures-core.Gesture\n * @see {ReturnTypes.SwipeData}\n * @memberof westures\n *\n * @param {Element} element - The element to which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n * is recognized on the associated element.\n * @param {object} [options] - Gesture customization options.\n * @param {westures-core.STATE_KEYS[]} [options.enableKeys=[]] - List of keys\n * which will enable the gesture. The gesture will not be recognized unless one\n * of these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the enable key is always down.\n * @param {westures-core.STATE_KEYS[]} [options.disableKeys=[]] - List of keys\n * which will disable the gesture. The gesture will not be recognized if one of\n * these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the disable key is never down.\n * @param {number} [options.minInputs=1] - The minimum number of pointers that\n * must be active for the gesture to be recognized. Uses >=.\n * @param {number} [options.maxInputs=Number.MAX_VALUE] - The maximum number of\n * pointers that may be active for the gesture to be recognized. Uses <=.\n */\nclass Swipe extends Gesture {\n  constructor(element, handler, options = {}) {\n    super('swipe', element, handler, options);\n\n    /**\n     * Moves list.\n     *\n     * @type {object[]}\n     */\n    this.moves = [];\n\n    /**\n     * Data to emit when all points have ended.\n     *\n     * @type {ReturnTypes.SwipeData}\n     */\n    this.saved = null;\n  }\n\n  /**\n   * Restart the swipe state for a new numper of inputs.\n   */\n  restart() {\n    this.moves = [];\n    this.saved = null;\n  }\n\n  start() {\n    this.restart();\n  }\n\n  move(state) {\n    this.moves.push({\n      time:  Date.now(),\n      point: state.centroid,\n    });\n\n    if (this.moves.length > PROGRESS_STACK_SIZE) {\n      this.moves.splice(0, this.moves.length - PROGRESS_STACK_SIZE);\n    }\n  }\n\n  end(state) {\n    const result = this.getResult();\n    this.moves = [];\n\n    if (state.active.length > 0) {\n      this.saved = result;\n      return null;\n    }\n\n    this.saved = null;\n    return Swipe.validate(result);\n  }\n\n  cancel() {\n    this.restart();\n  }\n\n  /**\n   * Get the swipe result.\n   *\n   * @returns {?ReturnTypes.SwipeData}\n   */\n  getResult() {\n    if (this.moves.length < PROGRESS_STACK_SIZE) {\n      return this.saved;\n    }\n    const vlim = PROGRESS_STACK_SIZE - 1;\n    const { point, time } = this.moves[vlim];\n    const velocity = Swipe.calc_velocity(this.moves, vlim);\n    const direction = Swipe.calc_angle(this.moves, vlim);\n    const centroid = point;\n    return { point, velocity, direction, time, centroid };\n  }\n\n  /**\n   * Validates that an emit should occur with the given data.\n   *\n   * @static\n   * @param {?ReturnTypes.SwipeData} data\n   * @returns {?ReturnTypes.SwipeData}\n   */\n  static validate(data) {\n    if (data == null) return null;\n    return (Date.now() - data.time > MS_THRESHOLD) ? null : data;\n  }\n\n  /**\n   * Calculates the angle of movement along a series of moves.\n   *\n   * @static\n   * @see {@link https://en.wikipedia.org/wiki/Mean_of_circular_quantities}\n   *\n   * @param {{time: number, point: westures-core.Point2D}} moves - The moves\n   * list to process.\n   * @param {number} vlim - The number of moves to process.\n   *\n   * @return {number} The angle of the movement.\n   */\n  static calc_angle(moves, vlim) {\n    const point = moves[vlim].point;\n    let sin = 0;\n    let cos = 0;\n    for (let i = 0; i < vlim; ++i) {\n      const angle = moves[i].point.angleTo(point);\n      sin += Math.sin(angle);\n      cos += Math.cos(angle);\n    }\n    sin /= vlim;\n    cos /= vlim;\n    return Math.atan2(sin, cos);\n  }\n\n  /**\n   * Local helper function for calculating the velocity between two timestamped\n   * points.\n   *\n   * @static\n   * @param {object} start\n   * @param {westures-core.Point2D} start.point\n   * @param {number} start.time\n   * @param {object} end\n   * @param {westures-core.Point2D} end.point\n   * @param {number} end.time\n   *\n   * @return {number} velocity from start to end point.\n   */\n  static velocity(start, end) {\n    const distance = end.point.distanceTo(start.point);\n    const time = end.time - start.time + 1;\n    return distance / time;\n  }\n\n  /**\n   * Calculates the veloctiy of movement through a series of moves.\n   *\n   * @static\n   * @param {{time: number, point: westures-core.Point2D}} moves - The moves\n   * list to process.\n   * @param {number} vlim - The number of moves to process.\n   *\n   * @return {number} The velocity of the moves.\n   */\n  static calc_velocity(moves, vlim) {\n    let max = 0;\n    for (let i = 0; i < vlim; ++i) {\n      const current = Swipe.velocity(moves[i], moves[i + 1]);\n      if (current > max) max = current;\n    }\n    return max;\n  }\n}\n\nmodule.exports = Swipe;\n\n","/*\n * Contains the Rotate class.\n */\n\n'use strict';\n\nconst { angularDifference, Smoothable } = require('../core');\nconst Pivotable = require('./Pivotable.js');\n\n/**\n * Data returned when a Swivel is recognized.\n *\n * @typedef {Object} SwivelData\n * @mixes ReturnTypes.BaseData\n *\n * @property {number} rotation - In radians, the change in angle since last\n * emit.\n * @property {westures-core.Point2D} pivot - The pivot point.\n *\n * @memberof ReturnTypes\n */\n\n/**\n * A Swivel is a single input rotating around a fixed point. The fixed point is\n * determined by the input's location at its 'start' phase.\n *\n * @extends westures-core.Gesture\n * @see {ReturnTypes.SwivelData}\n * @memberof westures\n *\n * @param {Element} element - The element to which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n * is recognized on the associated element.\n * @param {object} [options] - Gesture customization options.\n * @param {westures-core.STATE_KEYS[]} [options.enableKeys=[]] - List of keys\n * which will enable the gesture. The gesture will not be recognized unless one\n * of these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the enable key is always down.\n * @param {westures-core.STATE_KEYS[]} [options.disableKeys=[]] - List of keys\n * which will disable the gesture. The gesture will not be recognized if one of\n * these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the disable key is never down.\n * @param {number} [options.minInputs=1] - The minimum number of pointers that\n * must be active for the gesture to be recognized. Uses >=.\n * @param {number} [options.maxInputs=Number.MAX_VALUE] - The maximum number of\n * pointers that may be active for the gesture to be recognized. Uses <=.\n * @param {boolean} [options.applySmoothing=true] - Whether to apply inertial\n * smoothing for systems with coarse pointers.\n * @param {number} [options.deadzoneRadius=15] - The radius in pixels around the\n * start point in which to do nothing.\n * @param {Element} [options.dynamicPivot=false] - Normally the center point of\n * the gesture's element is used as the pivot. If this option is set, the\n * initial contact point with the element is used as the pivot instead.\n */\nclass Swivel extends Pivotable {\n  constructor(element, handler, options = {}) {\n    super('swivel', element, handler, options);\n\n    /*\n     * The outgoing data, with optional inertial smoothing.\n     *\n     * @override\n     * @type {westures-core.Smoothable<number>}\n     */\n    this.outgoing = new Smoothable(options);\n  }\n\n  updatePrevious(state) {\n    this.previous = this.pivot.angleTo(state.centroid);\n  }\n\n  move(state) {\n    const pivot = this.pivot;\n    const angle = pivot.angleTo(state.centroid);\n    const rotation = angularDifference(angle, this.previous);\n\n    let rv = null;\n    if (pivot.distanceTo(state.centroid) > this.options.deadzoneRadius) {\n      rv = { rotation: this.outgoing.next(rotation), pivot };\n    }\n\n    /*\n     * Updating the previous angle regardless of emit prevents sudden flips when\n     * the user exits the deadzone circle.\n     */\n    this.previous = angle;\n\n    return rv;\n  }\n}\n\nmodule.exports = Swivel;\n\n","/*\n * Contains the Tap class.\n */\n\n'use strict';\n\nconst { Gesture, Point2D } = require('../core');\n\n/**\n * Data returned when a Tap is recognized.\n *\n * @typedef {Object} TapData\n * @mixes ReturnTypes.BaseData\n *\n * @property {number} x - x coordinate of tap point.\n * @property {number} y - y coordinate of tap point.\n *\n * @memberof ReturnTypes\n */\n\n/**\n * A Tap is defined as a touchstart to touchend event in quick succession.\n *\n * @extends westures-core.Gesture\n * @see {ReturnTypes.TapData}\n * @memberof westures\n *\n * @param {Element} element - The element to which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n * is recognized on the associated element.\n * @param {object} [options] - Gesture customization options.\n * @param {westures-core.STATE_KEYS[]} [options.enableKeys=[]] - List of keys\n * which will enable the gesture. The gesture will not be recognized unless one\n * of these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the enable key is always down.\n * @param {westures-core.STATE_KEYS[]} [options.disableKeys=[]] - List of keys\n * which will disable the gesture. The gesture will not be recognized if one of\n * these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the disable key is never down.\n * @param {number} [options.minInputs=1] - The minimum number of pointers that\n * must be active for the gesture to be recognized. Uses >=.\n * @param {number} [options.maxInputs=Number.MAX_VALUE] - The maximum number of\n * pointers that may be active for the gesture to be recognized. Uses <=.\n * @param {number} [options.minDelay=0] - The minimum delay between a touchstart\n * and touchend can be configured in milliseconds.\n * @param {number} [options.maxDelay=300] - The maximum delay between a\n * touchstart and touchend can be configured in milliseconds.\n * @param {number} [options.maxRetain=300] - The maximum time after a tap ends\n * before it is discarded can be configured in milliseconds. Useful for\n * multi-tap gestures, to allow things like slow \"double clicks\".\n * @param {number} [options.numTaps=1] - Number of taps to require.\n * @param {number} [options.tolerance=10] - The tolerance in pixels an input can\n * move before it will no longer be considered part of a tap.\n */\nclass Tap extends Gesture {\n  constructor(element, handler, options = {}) {\n    super('tap', element, handler, { ...Tap.DEFAULTS, ...options });\n\n    /**\n     * An array of inputs that have ended recently.\n     *\n     * @type {Input[]}\n     */\n    this.taps = [];\n  }\n\n  end(state) {\n    const now = Date.now();\n    const { minDelay, maxDelay, maxRetain, numTaps, tolerance } = this.options;\n\n    // Save the recently ended inputs as taps.\n    this.taps = this.taps.concat(state.getInputsInPhase('end'))\n      .filter(input => {\n        const elapsed = input.elapsedTime;\n        const tdiff = now - input.current.time;\n        return (\n          elapsed <= maxDelay\n          && elapsed >= minDelay\n          && tdiff <= maxRetain\n        );\n      });\n\n    // Validate the list of taps.\n    if (this.taps.length !== numTaps ||\n      this.taps.some(i => i.totalDistance() > tolerance)) {\n      return null;\n    }\n\n    const centroid = Point2D.centroid(this.taps.map(i => i.current.point));\n    this.taps = []; // Critical! Used taps need to be cleared!\n    return { centroid, ...centroid };\n  }\n}\n\nTap.DEFAULTS = Object.freeze({\n  minDelay:  0,\n  maxDelay:  300,\n  maxRetain: 300,\n  numTaps:   1,\n  tolerance: 10,\n});\n\nmodule.exports = Tap;\n\n","/*\n * Contains the Track class.\n */\n\n'use strict';\n\nconst { Gesture } = require('../core');\n\n/**\n * Data returned when a Track is recognized.\n *\n * @typedef {Object} TrackData\n * @mixes ReturnTypes.BaseData\n *\n * @property {westures-core.Point2D[]} active - Points currently in 'start' or\n *    'move' phase.\n *\n * @memberof ReturnTypes\n */\n\n/**\n * A Track gesture forwards a list of active points and their centroid on each\n * of the selected phases.\n *\n * @extends westures-core.Gesture\n * @see {ReturnTypes.TrackData}\n * @memberof westures\n *\n * @param {Element} element - The element to which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n * is recognized on the associated element.\n * @param {object} [options] - Gesture customization options.\n * @param {westures-core.STATE_KEYS[]} [options.enableKeys=[]] - List of keys\n * which will enable the gesture. The gesture will not be recognized unless one\n * of these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the enable key is always down.\n * @param {westures-core.STATE_KEYS[]} [options.disableKeys=[]] - List of keys\n * which will disable the gesture. The gesture will not be recognized if one of\n * these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the disable key is never down.\n * @param {number} [options.minInputs=1] - The minimum number of pointers that\n * must be active for the gesture to be recognized. Uses >=.\n * @param {number} [options.maxInputs=Number.MAX_VALUE] - The maximum number of\n * pointers that may be active for the gesture to be recognized. Uses <=.\n * @param {string[]} [options.phases=[]] Phases to recognize. Entries can be any\n * or all of 'start', 'move', 'end', and 'cancel'.\n */\nclass Track extends Gesture {\n  constructor(element, handler, options = {}) {\n    super('track', element, handler, { ...Track.DEFAULTS, ...options });\n  }\n\n  /**\n   * Filters out the state's data, down to what should be emitted.\n\n   * @param {State} state - current input state.\n   * @return {ReturnTypes.TrackData}\n   */\n  data({ activePoints }) {\n    return { active: activePoints };\n  }\n\n  tracks(phase) {\n    return this.options.phases.includes(phase);\n  }\n\n  start(state) {\n    return this.tracks('start') ? this.data(state) : null;\n  }\n\n  move(state) {\n    return this.tracks('move') ? this.data(state) : null;\n  }\n\n  end(state) {\n    return this.tracks('end') ? this.data(state) : null;\n  }\n\n  cancel(state) {\n    return this.tracks('cancel') ? this.data(state) : null;\n  }\n}\n\nTrack.DEFAULTS = Object.freeze({\n  phases: Object.freeze([]),\n});\n\nmodule.exports = Track;\n\n","/**\n * The API interface for Westures. Defines a number of gestures on top of the\n * engine provided by {@link\n * https://mvanderkamp.github.io/westures-core/index.html|westures-core}.\n *\n * @namespace westures\n */\n\n'use strict';\n\nconst core = require('./core');\n\nconst Pan     = require('./src/Pan.js');\nconst Pinch   = require('./src/Pinch.js');\nconst Press   = require('./src/Press.js');\nconst Pull    = require('./src/Pull.js');\nconst Rotate  = require('./src/Rotate.js');\nconst Swipe   = require('./src/Swipe.js');\nconst Swivel  = require('./src/Swivel.js');\nconst Tap     = require('./src/Tap.js');\nconst Track   = require('./src/Track.js');\n\nmodule.exports = {\n  Pan,\n  Pinch,\n  Press,\n  Pull,\n  Rotate,\n  Swipe,\n  Swivel,\n  Tap,\n  Track,\n  ...core,\n};\n\n/**\n * Here are the return \"types\" of the gestures that are included in this\n * package.\n *\n * @namespace ReturnTypes\n */\n\n/**\n * The base data that is included for all emitted gestures.\n *\n * @typedef {Object} BaseData\n *\n * @property {westures-core.Point2D} centroid - The centroid of the input\n * points.\n * @property {Event} event - The input event which caused the gesture to be\n * recognized.\n * @property {string} phase - 'start', 'move', 'end', or 'cancel'.\n * @property {string} type - The name of the gesture as specified by its\n * designer.\n * @property {Element} target - The bound target of the gesture.\n *\n * @memberof ReturnTypes\n */\n\n"],"names":["$869ff68f0de25151$var$$17807945cdde5d67$var$$de0d6a332419bf3c$var$g_id","$869ff68f0de25151$var$$17807945cdde5d67$var$$de0d6a332419bf3c$var$Gesture","constructor","type","element","handler","options","TypeError","this","id","DEFAULTS","isEnabled","state","count","active","length","event","enableKeys","disableKeys","minInputs","maxInputs","some","k","start","move","end","cancel","evaluateHook","hook","data","recognize","centroid","phase","target","Number","MAX_VALUE","$869ff68f0de25151$var$$17807945cdde5d67$var$$de0d6a332419bf3c$exports","$869ff68f0de25151$var$$17807945cdde5d67$var$$6c3676f10a43b740$var$Point2D","x","y","angleTo","point","Math","atan2","anglesTo","points","map","averageDistanceTo","totalDistanceTo","clone","distanceTo","hypot","minus","plus","reduce","d","p","static","total","sum","pt","$869ff68f0de25151$var$$17807945cdde5d67$var$$6c3676f10a43b740$exports","$869ff68f0de25151$var$$17807945cdde5d67$var$$be6f0e84320366a7$var$CANCEL","$869ff68f0de25151$var$$17807945cdde5d67$var$$be6f0e84320366a7$var$END","$869ff68f0de25151$var$$17807945cdde5d67$var$$be6f0e84320366a7$var$MOVE","$869ff68f0de25151$var$$17807945cdde5d67$var$$be6f0e84320366a7$var$START","$869ff68f0de25151$var$$17807945cdde5d67$var$$0ca7bfe1c074e8ca$require$PHASE","$869ff68f0de25151$var$$17807945cdde5d67$var$$be6f0e84320366a7$exports","CANCEL_EVENTS","KEYBOARD_EVENTS","MOUSE_EVENTS","POINTER_EVENTS","TOUCH_EVENTS","STATE_KEYS","STATE_KEY_STRINGS","CANCEL","END","MOVE","START","PHASE","blur","pointercancel","touchcancel","mouseup","pointerup","touchend","mousemove","pointermove","touchmove","mousedown","pointerdown","touchstart","PHASES","$869ff68f0de25151$var$$17807945cdde5d67$var$$0ca7bfe1c074e8ca$exports","identifier","clientX","clientY","changedTouches","Array","from","find","touch","$869ff68f0de25151$var$$17807945cdde5d67$var$$0ca7bfe1c074e8ca$var$getEventObject","time","Date","now","$869ff68f0de25151$var$$17807945cdde5d67$var$$4559ecf940edc78d$var$PI_2","PI","$869ff68f0de25151$var$$17807945cdde5d67$var$$4559ecf940edc78d$var$PI_NVE","$869ff68f0de25151$var$$17807945cdde5d67$var$$4559ecf940edc78d$var$setFilter","set","predicate","result","Set","forEach","add","$869ff68f0de25151$var$$17807945cdde5d67$var$$e2125e2e71e37a0c$require$getPropagationPath","$869ff68f0de25151$var$$17807945cdde5d67$var$$4559ecf940edc78d$exports","angularDifference","a","b","diff","getPropagationPath","composedPath","path","node","document","parentNode","push","window","setDifference","left","right","has","setFilter","$869ff68f0de25151$var$$17807945cdde5d67$var$$e2125e2e71e37a0c$exports","currentData","initialElements","WeakSet","initial","current","previous","startTime","elapsedTime","totalDistance","update","$869ff68f0de25151$var$$17807945cdde5d67$var$$639be6fb478a6d5a$require$CANCEL","$869ff68f0de25151$var$$17807945cdde5d67$var$$639be6fb478a6d5a$require$END","$869ff68f0de25151$var$$17807945cdde5d67$var$$639be6fb478a6d5a$require$MOVE","$869ff68f0de25151$var$$17807945cdde5d67$var$$639be6fb478a6d5a$require$PHASE","$869ff68f0de25151$var$$17807945cdde5d67$var$$639be6fb478a6d5a$require$START","$869ff68f0de25151$var$$17807945cdde5d67$var$$639be6fb478a6d5a$var$symbols","Symbol","for","$869ff68f0de25151$var$$17807945cdde5d67$var$$639be6fb478a6d5a$var$update_fns","TouchEvent","updateInput","PointerEvent","pointerId","MouseEvent","button","$869ff68f0de25151$var$$17807945cdde5d67$var$$639be6fb478a6d5a$exports","Map","inputs","activePoints","clearEndedInputs","v","delete","getInputsInPhase","filter","i","getInputsNotInPhase","hasNoInputs","size","setPointerCapture","e","releasePointerCapture","e1","get","console","warn","updateAllInputs","name","call","updateFields","values","$869ff68f0de25151$var$$17807945cdde5d67$var$$b66a0f22c18e3e3d$require$CANCEL_EVENTS","$869ff68f0de25151$var$$17807945cdde5d67$var$$b66a0f22c18e3e3d$require$KEYBOARD_EVENTS","$869ff68f0de25151$var$$17807945cdde5d67$var$$b66a0f22c18e3e3d$require$MOUSE_EVENTS","$869ff68f0de25151$var$$17807945cdde5d67$var$$b66a0f22c18e3e3d$require$POINTER_EVENTS","$869ff68f0de25151$var$$17807945cdde5d67$var$$b66a0f22c18e3e3d$require$TOUCH_EVENTS","$869ff68f0de25151$var$$17807945cdde5d67$var$$b66a0f22c18e3e3d$require$STATE_KEY_STRINGS","$869ff68f0de25151$var$$17807945cdde5d67$var$$b66a0f22c18e3e3d$require$PHASE","$869ff68f0de25151$var$$17807945cdde5d67$var$$b66a0f22c18e3e3d$require$CANCEL","$869ff68f0de25151$var$$17807945cdde5d67$var$$b66a0f22c18e3e3d$require$END","$869ff68f0de25151$var$$17807945cdde5d67$var$$b66a0f22c18e3e3d$require$START","$869ff68f0de25151$var$$17807945cdde5d67$var$$b66a0f22c18e3e3d$require$setDifference","$869ff68f0de25151$var$$17807945cdde5d67$var$$b66a0f22c18e3e3d$require$setFilter","$869ff68f0de25151$var$$17807945cdde5d67$var$$b66a0f22c18e3e3d$var$Region","gestures","activeGestures","potentialGestures","activate","eventNames","preferPointer","concat","arbitrate","bind","eventName","addEventListener","capture","once","passive","handleKeyboardEvent","preventDefault","input","gesture","resetActiveGestures","indexOf","key","oldActiveGestures","setActiveGestures","setPotentialGestures","updateActiveGestures","isInitial","pruneActiveGestures","addGesture","style","touchAction","removeGesture","getGesturesByElement","removeGesturesByElement","g","$869ff68f0de25151$var$$17807945cdde5d67$var$$b66a0f22c18e3e3d$exports","$869ff68f0de25151$var$$17807945cdde5d67$var$$01c3d7b128023e4f$var$cascade","$869ff68f0de25151$var$$17807945cdde5d67$var$$01c3d7b128023e4f$var$smooth","$869ff68f0de25151$var$$17807945cdde5d67$var$$01c3d7b128023e4f$var$Smoothable","final_options","next","isRequested","matchMedia","matches","$869ff68f0de25151$var$$17807945cdde5d67$var$$01c3d7b128023e4f$var$smoothingIsApplicable","applySmoothing","identity","restart","average","$869ff68f0de25151$var$$edded22326d64913$require$Gesture","$869ff68f0de25151$var$$17807945cdde5d67$exports","Gesture","Input","Point2D","PointerData","Region","Smoothable","State","$869ff68f0de25151$var$$edded22326d64913$require$Point2D","$869ff68f0de25151$var$$edded22326d64913$require$Smoothable","$869ff68f0de25151$var$$edded22326d64913$exports","super","outgoing","translation","$869ff68f0de25151$var$$a29eb49c9650e38a$require$Gesture","$869ff68f0de25151$var$$a29eb49c9650e38a$require$Smoothable","$869ff68f0de25151$var$$a29eb49c9650e38a$var$Pinch","distance","scale","Object","freeze","$869ff68f0de25151$var$$a29eb49c9650e38a$exports","$869ff68f0de25151$var$$044241a6e313bbcb$require$Gesture","$869ff68f0de25151$var$$044241a6e313bbcb$require$Point2D","$869ff68f0de25151$var$$044241a6e313bbcb$require$MOVE","$869ff68f0de25151$var$$044241a6e313bbcb$var$Press","originalInputs","setTimeout","includes","tolerance","delay","$869ff68f0de25151$var$$044241a6e313bbcb$exports","$869ff68f0de25151$var$$b6747a8030ff7e4d$require$Smoothable","$869ff68f0de25151$var$$5618dc3399c82d06$require$Gesture","$869ff68f0de25151$var$$5618dc3399c82d06$require$Point2D","$869ff68f0de25151$var$$5618dc3399c82d06$require$Smoothable","$869ff68f0de25151$var$$5618dc3399c82d06$var$Pivotable","pivot","rect","getBoundingClientRect","width","top","height","updatePrevious","dynamicPivot","getClientCenter","deadzoneRadius","$869ff68f0de25151$var$$5618dc3399c82d06$exports","$869ff68f0de25151$var$$b6747a8030ff7e4d$exports","rv","$869ff68f0de25151$var$$2779699df4dafe8f$require$angularDifference","$869ff68f0de25151$var$$2779699df4dafe8f$require$Gesture","$869ff68f0de25151$var$$2779699df4dafe8f$require$Smoothable","$869ff68f0de25151$var$$2779699df4dafe8f$var$Rotate","previousAngles","stagedAngles","angle","index","rotation","$869ff68f0de25151$var$$2779699df4dafe8f$exports","$869ff68f0de25151$var$$29f6d3783b0fe128$require$Gesture","$869ff68f0de25151$var$$29f6d3783b0fe128$var$Swipe","moves","saved","splice","getResult","validate","$869ff68f0de25151$var$$29f6d3783b0fe128$var$PROGRESS_STACK_SIZE","velocity","calc_velocity","direction","calc_angle","vlim","sin","cos","max","$869ff68f0de25151$var$$29f6d3783b0fe128$exports","$869ff68f0de25151$var$$5bf1e923ca9fec67$require$angularDifference","$869ff68f0de25151$var$$5bf1e923ca9fec67$require$Smoothable","$869ff68f0de25151$var$$5bf1e923ca9fec67$exports","$869ff68f0de25151$var$$2f0219f585763ab0$require$Gesture","$869ff68f0de25151$var$$2f0219f585763ab0$require$Point2D","$869ff68f0de25151$var$$2f0219f585763ab0$var$Tap","taps","minDelay","maxDelay","maxRetain","numTaps","elapsed","tdiff","$869ff68f0de25151$var$$2f0219f585763ab0$exports","$869ff68f0de25151$var$$13a50dd07826f9eb$require$Gesture","$869ff68f0de25151$var$$13a50dd07826f9eb$var$Track","tracks","phases","$01ff5452a470b77e$var$region","$869ff68f0de25151$exports","Pan","Pinch","Press","Pull","Rotate","Swipe","Swivel","Tap","Track","$01ff5452a470b77e$var$container","querySelector","$01ff5452a470b77e$var$random8Bit","floor","random","$01ff5452a470b77e$var$reduce","value","abs","$01ff5452a470b77e$var$Interactable","color","createElement","backgroundColor","label","innerText","appendChild","velocityX","velocityY","animate","update_fn","swipe_interval","swipe_fn","swipeAnimation","setupTracking","fns","requestAnimationFrame","clearInterval","keys","randomBackground","R","G","B","addTap","addPress","addRotate","addPan","addSwipe","setInterval","addSwivel","pivotCenter","addPinch","addPull","rotate","translate","transform","$01ff5452a470b77e$var$INTERVAL","$01ff5452a470b77e$var$PALETTE","hue","$01ff5452a470b77e$var$cidx","$01ff5452a470b77e$var$nextColour"],"version":3,"file":"sample.js.map"}