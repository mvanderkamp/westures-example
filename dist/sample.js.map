{"mappings":"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","sources":["node_modules/westures-core/src/Gesture.js","node_modules/westures-core/src/Point2D.js","node_modules/westures-core/src/PointerData.js","node_modules/westures-core/src/constants.js","node_modules/westures-core/src/utils.js","node_modules/westures-core/src/Input.js","node_modules/westures-core/src/State.js","node_modules/westures-core/src/Region.js","node_modules/westures-core/src/Smoothable.js","node_modules/westures/src/Pan.js","node_modules/westures-core/index.js","node_modules/westures/src/Pinch.js","node_modules/westures/src/Press.js","node_modules/westures/src/Pull.js","node_modules/westures/src/Pivotable.js","node_modules/westures/src/Rotate.js","node_modules/westures/src/Swipe.js","node_modules/westures/src/Swivel.js","node_modules/westures/src/Tap.js","node_modules/westures/src/Track.js","sample.js","node_modules/westures/index.js"],"names":["g_id","Gesture","type","element","handler","options","arguments","length","undefined","$b8165f784711ca2ea9509301ec460987$var$_classCallCheck","this","TypeError","id","concat","$b8165f784711ca2ea9509301ec460987$var$_objectSpread","DEFAULTS","state","count","active","event","_this$options","enableKeys","disableKeys","minInputs","maxInputs","some","k","hook","data","recognize","centroid","phase","target","Object","freeze","Number","MAX_VALUE","$b8165f784711ca2ea9509301ec460987$exports","$a9f1c16eb2844ad5078aca5b9c9cadcd$exports","Point2D","x","y","$a9f1c16eb2844ad5078aca5b9c9cadcd$var$_classCallCheck","points","total","sum","reduce","pt","point","Math","atan2","totalDistanceTo","hypot","_this","d","p","distanceTo","PHASE","$e65c3b58968a8967490c75ab927ceb$exports","CANCEL_EVENTS","KEYBOARD_EVENTS","MOUSE_EVENTS","POINTER_EVENTS","TOUCH_EVENTS","STATE_KEYS","STATE_KEY_STRINGS","CANCEL","END","MOVE","START","blur","pointercancel","touchcancel","mouseup","pointerup","touchend","mousemove","pointermove","touchmove","mousedown","pointerdown","touchstart","$e2c63ed0625c9d9a3637714195d71d1$exports","PointerData","identifier","$e2c63ed0625c9d9a3637714195d71d1$var$_classCallCheck","_getEventObject","changedTouches","Array","from","find","touch","getEventObject","clientX","clientY","time","Date","now","PI_2","PI","PI_NVE","setFilter","set","predicate","result","Set","forEach","add","getPropagationPath","$cb88c35c5048ce067deba28299d310e$exports","angularDifference","a","b","diff","composedPath","path","node","document","parentNode","push","window","setDifference","left","right","has","$b3c6ae729a0c29e3ffb8e800a3136321$exports","Input","$b3c6ae729a0c29e3ffb8e800a3136321$var$_classCallCheck","currentData","initialElements","WeakSet","initial","current","previous","symbols","inputs","Symbol","for","update_fns","TouchEvent","updateInput","PointerEvent","pointerId","MouseEvent","button","$bbe3896aa15254af9d176bc7ed12134$exports","State","$bbe3896aa15254af9d176bc7ed12134$var$_classCallCheck","Map","activePoints","_this2","v","delete","filter","i","size","setPointerCapture","e","releasePointerCapture","get","update","console","warn","constructor","name","call","updateFields","values","getInputsNotInPhase","map","Region","$b35e9ce38371f4b5c2c71082$var$_classCallCheck","settings","$b35e9ce38371f4b5c2c71082$var$_objectSpread","gestures","activeGestures","potentialGestures","capture","preventDefault","activate","eventNames","arbitrate","bind","eventName","addEventListener","once","passive","cancel","handleKeyboardEvent","input","gesture","evaluateHook","resetActiveGestures","_this3","indexOf","key","oldActiveGestures","setActiveGestures","_this4","isEnabled","isInitial","setPotentialGestures","hasNoInputs","_this5","updateAllInputs","updateActiveGestures","clearEndedInputs","pruneActiveGestures","_this6","getGesturesByElement","g","removeGesture","$b35e9ce38371f4b5c2c71082$exports","cascade","smooth","smoothingIsApplicable","isRequested","matchMedia","matches","Smoothable","$fa19861f4da54e7560de628cf88411e8$var$_classCallCheck","final_options","$fa19861f4da54e7560de628cf88411e8$var$_objectSpread","next","applySmoothing","identity","average","$a682b04db3f0b839c6a1248a2c0b00e9$exports","$a682b04db3f0b839c6a1248a2c0b00e9$var$_objectSpread","$f916f27a9eac277b62251d321cc72$exports","Pan","$f916f27a9eac277b62251d321cc72$var$_classCallCheck","_super","outgoing","$f916f27a9eac277b62251d321cc72$var$_objectSpread","restart","translation","minus","Pinch","$c96eb23c7cc561d80bc3502a9ebe01d$var$_classCallCheck","$c96eb23c7cc561d80bc3502a9ebe01d$var$_objectSpread","averageDistanceTo","distance","scale","$c96eb23c7cc561d80bc3502a9ebe01d$exports","Press","$e2d3614b4e65ef9b7a0a587c651b94f5$var$_classCallCheck","$e2d3614b4e65ef9b7a0a587c651b94f5$var$_objectSpread","delay","tolerance","identifiers","setTimeout","$e2d3614b4e65ef9b7a0a587c651b94f5$exports","getClientCenter","rect","getBoundingClientRect","width","top","height","Pivotable","$b6755fdd269861ed8a6994146$var$_classCallCheck","$b6755fdd269861ed8a6994146$var$_objectSpread","deadzoneRadius","dynamicPivot","pivot","updatePrevious","$c6441e036cb91e00d207bc27797f4e$exports","Pull","$c6441e036cb91e00d207bc27797f4e$var$_classCallCheck","$c6441e036cb91e00d207bc27797f4e$var$_objectSpread","rv","$b6755fdd269861ed8a6994146$exports","Rotate","$ac0822020c0a3735d09983cff2e194c0$var$_classCallCheck","$ac0822020c0a3735d09983cff2e194c0$var$_objectSpread","previousAngles","angleTo","stagedAngles","anglesFromCentroid","angle","index","rotation","getRotation","$ac0822020c0a3735d09983cff2e194c0$exports","$f4d5991566b501399214$exports","Swipe","$f4d5991566b501399214$var$_classCallCheck","moves","saved","splice","getResult","validate","_this$moves$vlim","PROGRESS_STACK_SIZE","velocity","vlim","start","end","max","calc_velocity","direction","sin","cos","calc_angle","$d76a8f3240d2450f48fd5fd735a2e29$exports","Swivel","$d76a8f3240d2450f48fd5fd735a2e29$var$_classCallCheck","Tap","$b98740836e10ae9284e0abc044614$var$_classCallCheck","$b98740836e10ae9284e0abc044614$var$_objectSpread","minDelay","maxDelay","numTaps","taps","getInputsInPhase","tdiff","startTime","totalDistance","$b98740836e10ae9284e0abc044614$exports","Track","$f46b2a0b3ca8dd5483a1cee1cc291d28$var$_classCallCheck","$f46b2a0b3ca8dd5483a1cee1cc291d28$var$_objectSpread","trackStart","phases","includes","trackMove","trackEnd","trackCancel","_ref","region","$b8279329fe4b6cfcbcc7d7d86b0faa73$exports","$b8279329fe4b6cfcbcc7d7d86b0faa73$var$_objectSpread","body","container","querySelector","random8Bit","floor","random","value","abs","Interactable","color","$e0468e1fb8d0d74e2411cd420d629dc$var$_classCallCheck","createElement","style","backgroundColor","label","innerText","appendChild","velocityX","velocityY","animate","update_fn","swipe_interval","swipe_fn","swipeAnimation","setupTracking","addGesture","requestAnimationFrame","clearInterval","R","G","B","randomBackground","setInterval","_this7","$e0468e1fb8d0d74e2411cd420d629dc$var$_objectSpread","pivotCenter","_this8","_this9","rotate","translate","transform","INTERVAL","PALETTE","hue","cidx","nextColour","addTap","addPan","addPinch","addRotate","addSwipe","addPress","addSwivel","addPull"],"version":3,"file":"sample.js.map","sourcesContent":["'use strict';\n\nlet g_id = 0;\n\n/**\n * The Gesture class that all gestures inherit from. A custom gesture class will\n * need to override some or all of the four phase \"hooks\": start, move, end, and\n * cancel.\n *\n * @memberof westures-core\n *\n * @param {string} type - The name of the gesture.\n * @param {Element} element - The element to which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n *    is recognized on the associated element.\n * @param {object} [options] - Generic gesture options\n * @param {westures-core.STATE_KEYS[]} [options.enableKeys=[]] - List of keys\n * which will enable the gesture. The gesture will not be recognized unless one\n * of these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the enable key is always down.\n * @param {westures-core.STATE_KEYS[]} [options.disableKeys=[]] - List of keys\n * which will disable the gesture. The gesture will not be recognized if one of\n * these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the disable key is never down.\n * @param {number} [options.minInputs=1] - The minimum number of pointers that\n * must be active for the gesture to be recognized. Uses >=.\n * @param {number} [options.maxInputs=Number.MAX_VALUE] - The maximum number of\n * pointers that may be active for the gesture to be recognized. Uses <=.\n */\nclass Gesture {\n  constructor(type, element, handler, options = {}) {\n    if (typeof type !== 'string') {\n      throw new TypeError('Gestures require a string type / name');\n    }\n\n    /**\n     * The name of the gesture. (e.g. 'pan' or 'tap' or 'pinch').\n     *\n     * @type {string}\n     */\n    this.type = type;\n\n    /**\n     * The unique identifier for each gesture. This allows for distinctions\n     * across instances of Gestures that are created on the fly (e.g.\n     * gesture-tap-1, gesture-tap-2).\n     *\n     * @type {string}\n     */\n    this.id = `gesture-${this.type}-${g_id++}`;\n\n    /**\n     * The element to which to associate the gesture.\n     *\n     * @type {Element}\n     */\n    this.element = element;\n\n    /**\n     * The function handler to execute when the gesture is recognized on the\n     * associated element.\n     *\n     * @type {Function}\n     */\n    this.handler = handler;\n\n    /**\n     * The options settings.\n     *\n     * @type {object}\n     */\n    this.options = { ...Gesture.DEFAULTS, ...options };\n  }\n\n  /**\n   * Determines whether this gesture is enabled.\n   *\n   * @param {westures-core.State} state - The input state object of the current\n   * region.\n   *\n   * @return {boolean} true if enabled, false otherwise.\n   */\n  isEnabled(state) {\n    const count = state.active.length;\n    const event = state.event;\n    const { enableKeys, disableKeys, minInputs, maxInputs } = this.options;\n\n    return (minInputs <= count) && (maxInputs >= count) &&\n      (enableKeys.length === 0 || enableKeys.some(k => event[k])) &&\n      !disableKeys.some(k => event[k]);\n  }\n\n  /**\n   * Event hook for the start phase of a gesture.\n   *\n   * @param {westures-core.State} state - The input state object of the current\n   * region.\n   *\n   * @return {?Object} Gesture is considered recognized if an Object is\n   *    returned.\n   */\n  start() {\n    return null;\n  }\n\n  /**\n   * Event hook for the move phase of a gesture.\n   *\n   * @param {westures-core.State} state - The input state object of the current\n   * region.\n   *\n   * @return {?Object} Gesture is considered recognized if an Object is\n   *    returned.\n   */\n  move() {\n    return null;\n  }\n\n  /**\n   * Event hook for the end phase of a gesture.\n   *\n   * @param {westures-core.State} state - The input state object of the current\n   * region.\n   *\n   * @return {?Object} Gesture is considered recognized if an Object is\n   *    returned.\n   */\n  end() {\n    return null;\n  }\n\n  /**\n   * Event hook for when an input is cancelled.\n   *\n   * @param {westures-core.State} state - The input state object of the current\n   * region.\n   *\n   * @return {?Object} Gesture is considered recognized if an Object is\n   *    returned.\n   */\n  cancel() {\n    return null;\n  }\n\n  /**\n   * Evalutes the given gesture hook, and dispatches any data that is produced\n   * by calling [recognize]{@link westures-core.Gesture#recognize}.\n   *\n   * @param {string} hook - Must be one of 'start', 'move', 'end', or 'cancel'.\n   * @param {westures-core.State} state - The current State instance.\n   */\n  evaluateHook(hook, state) {\n    const data = this[hook](state);\n    if (data) {\n      this.recognize(hook, state, data);\n    }\n  }\n\n  /**\n   * Recognize a Gesture by calling the handler. Standardizes the way the\n   * handler is called so that classes extending Gesture can circumvent the\n   * evaluateHook approach but still provide results that have a common format.\n   *\n   * Note that the properties in the \"data\" object will receive priority when\n   * constructing the results. This can be used to override standard results\n   * such as the phase or the centroid.\n   *\n   * @param {string} hook - Must be one of 'start', 'move', 'end', or 'cancel'.\n   * @param {westures-core.State} state - current input state.\n   * @param {Object} data - Results data specific to the recognized gesture.\n   */\n  recognize(hook, state, data) {\n    this.handler({\n      centroid: state.centroid,\n      event:    state.event,\n      phase:    hook,\n      type:     this.type,\n      target:   this.element,\n      ...data,\n    });\n  }\n}\n\nGesture.DEFAULTS = Object.freeze({\n  enableKeys:  [],\n  disableKeys: [],\n  minInputs:   1,\n  maxInputs:   Number.MAX_VALUE,\n});\n\nmodule.exports = Gesture;\n\n","'use strict';\n\n/**\n * The Point2D class stores and operates on 2-dimensional points, represented as\n * x and y coordinates.\n *\n * @memberof westures-core\n *\n * @param {number} [ x=0 ] - The x coordinate of the point.\n * @param {number} [ y=0 ] - The y coordinate of the point.\n */\nclass Point2D {\n  constructor(x = 0, y = 0) {\n    /**\n     * The x coordinate of the point.\n     *\n     * @type {number}\n     */\n    this.x = x;\n\n    /**\n     * The y coordinate of the point.\n     *\n     * @type {number}\n     */\n    this.y = y;\n  }\n\n  /**\n   * Calculates the angle between this point and the given point.\n   *\n   * @param {!westures-core.Point2D} point - Projected point for calculating the\n   * angle.\n   *\n   * @return {number} Radians along the unit circle where the projected\n   * point lies.\n   */\n  angleTo(point) {\n    return Math.atan2(point.y - this.y, point.x - this.x);\n  }\n\n  /**\n   * Determine the average distance from this point to the provided array of\n   * points.\n   *\n   * @param {!westures-core.Point2D[]} points - the Point2D objects to calculate\n   *    the average distance to.\n   *\n   * @return {number} The average distance from this point to the provided\n   *    points.\n   */\n  averageDistanceTo(points) {\n    return this.totalDistanceTo(points) / points.length;\n  }\n\n  /**\n   * Clone this point.\n   *\n   * @return {westures-core.Point2D} A new Point2D, identical to this point.\n   */\n  clone() {\n    return new Point2D(this.x, this.y);\n  }\n\n  /**\n   * Calculates the distance between two points.\n   *\n   * @param {!westures-core.Point2D} point - Point to which the distance is\n   * calculated.\n   *\n   * @return {number} The distance between the two points, a.k.a. the\n   *    hypoteneuse.\n   */\n  distanceTo(point) {\n    return Math.hypot(point.x - this.x, point.y - this.y);\n  }\n\n  /**\n   * Subtract the given point from this point.\n   *\n   * @param {!westures-core.Point2D} point - Point to subtract from this point.\n   *\n   * @return {westures-core.Point2D} A new Point2D, which is the result of (this\n   * - point).\n   */\n  minus(point) {\n    return new Point2D(\n      this.x - point.x,\n      this.y - point.y,\n    );\n  }\n\n  /**\n   * Return the summation of this point to the given point.\n   *\n   * @param {!westures-core.Point2D} point - Point to add to this point.\n   *\n   * @return {westures-core.Point2D} A new Point2D, which is the addition of the\n   * two points.\n   */\n  plus(point) {\n    return new Point2D(\n      this.x + point.x,\n      this.y + point.y,\n    );\n  }\n\n  /**\n   * Calculates the total distance from this point to an array of points.\n   *\n   * @param {!westures-core.Point2D[]} points - The array of Point2D objects to\n   *    calculate the total distance to.\n   *\n   * @return {number} The total distance from this point to the provided points.\n   */\n  totalDistanceTo(points) {\n    return points.reduce((d, p) => d + this.distanceTo(p), 0);\n  }\n\n  /**\n   * Calculates the centroid of a list of points.\n   *\n   * @param {westures-core.Point2D[]} points - The array of Point2D objects for\n   * which to calculate the centroid.\n   *\n   * @return {westures-core.Point2D} The centroid of the provided points.\n   */\n  static centroid(points = []) {\n    if (points.length === 0) return null;\n\n    const total = Point2D.sum(points);\n    total.x /= points.length;\n    total.y /= points.length;\n    return total;\n  }\n\n  /**\n   * Calculates the sum of the given points.\n   *\n   * @param {westures-core.Point2D[]} points - The Point2D objects to sum up.\n   *\n   * @return {westures-core.Point2D} A new Point2D representing the sum of the\n   * given points.\n   */\n  static sum(points = []) {\n    return points.reduce(\n      (total, pt) => {\n        total.x += pt.x;\n        total.y += pt.y;\n        return total;\n      },\n      new Point2D(0, 0),\n    );\n  }\n}\n\nmodule.exports = Point2D;\n\n","'use strict';\n\nconst Point2D   = require('./Point2D.js');\nconst { PHASE } = require('./constants.js');\n\n/**\n * @private\n * @inner\n * @memberof westures-core.PointerData\n *\n * @return {Event} The Event object which corresponds to the given identifier.\n *    Contains clientX, clientY values.\n */\nfunction getEventObject(event, identifier) {\n  if (event.changedTouches) {\n    return Array.from(event.changedTouches).find(touch => {\n      return touch.identifier === identifier;\n    });\n  }\n  return event;\n}\n\n/**\n * Low-level storage of pointer data based on incoming data from an interaction\n * event.\n *\n * @memberof westures-core\n *\n * @param {Event} event - The event object being wrapped.\n * @param {number} identifier - The index of touch if applicable\n */\nclass PointerData {\n  constructor(event, identifier) {\n    const { clientX, clientY } = getEventObject(event, identifier);\n\n    /**\n     * The original event object.\n     *\n     * @type {Event}\n     */\n    this.event = event;\n\n    /**\n     * The type or 'phase' of this batch of pointer data. 'start' or 'move' or\n     * 'end' or 'cancel'\n     *\n     * @type {string}\n     */\n    this.type = PHASE[event.type];\n\n    /**\n     * The timestamp of the event in milliseconds elapsed since January 1, 1970,\n     * 00:00:00 UTC.\n     *\n     * @type {number}\n     */\n    this.time = Date.now();\n\n    /**\n     * The (x,y) coordinate of the event, wrapped in a Point2D.\n     *\n     * @type {westures-core.Point2D}\n     */\n    this.point = new Point2D(clientX, clientY);\n  }\n}\n\nmodule.exports = PointerData;\n\n","'use strict';\n\n/**\n * List of events that trigger the cancel phase.\n *\n * @memberof westures-core\n * @type {string[]}\n */\nconst CANCEL_EVENTS = Object.freeze([\n  'blur',\n  'pointercancel',\n  'touchcancel',\n]);\n\n/**\n * List of keyboard events that trigger a restart.\n *\n * @memberof westures-core\n * @type {string[]}\n */\nconst KEYBOARD_EVENTS = Object.freeze([\n  'keydown',\n  'keyup',\n]);\n\n/**\n * List of mouse events to listen to.\n *\n * @memberof westures-core\n * @type {string[]}\n */\nconst MOUSE_EVENTS = Object.freeze([\n  'mousedown',\n  'mousemove',\n  'mouseup',\n]);\n\n/**\n * List of pointer events to listen to.\n *\n * @memberof westures-core\n * @type {string[]}\n */\nconst POINTER_EVENTS = Object.freeze([\n  'pointerdown',\n  'pointermove',\n  'pointerup',\n]);\n\n/**\n * List of touch events to listen to.\n *\n * @memberof westures-core\n * @type {string[]}\n */\nconst TOUCH_EVENTS = Object.freeze([\n  'touchend',\n  'touchmove',\n  'touchstart',\n]);\n\n/**\n * List of potentially state-modifying keys.\n * Entries are: ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'].\n *\n * @memberof westures-core\n * @type {string[]}\n */\nconst STATE_KEYS = Object.freeze([\n  'altKey',\n  'ctrlKey',\n  'metaKey',\n  'shiftKey',\n]);\n\n/**\n * List of the 'key' values on KeyboardEvent objects of the potentially\n * state-modifying keys.\n *\n * @memberof westures-core\n * @type {string[]}\n */\nconst STATE_KEY_STRINGS = Object.freeze([\n  'Alt',\n  'Control',\n  'Meta',\n  'Shift',\n]);\n\n/**\n * The cancel phase.\n *\n * @memberof westures-core\n * @type {string}\n */\nconst CANCEL = 'cancel';\n\n/**\n * The end phase.\n *\n * @memberof westures-core\n * @type {string}\n */\nconst END = 'end';\n\n/**\n * The move phase.\n *\n * @memberof westures-core\n * @type {string}\n */\nconst MOVE = 'move';\n\n/**\n * The start phase.\n *\n * @memberof westures-core\n * @type {string}\n */\nconst START = 'start';\n\n/**\n * Object that normalizes the names of window events to be either of type start,\n * move, end, or cancel.\n *\n * @memberof westures-core\n * @type {object}\n */\nconst PHASE = Object.freeze({\n  blur:           CANCEL,\n  pointercancel:  CANCEL,\n  touchcancel:    CANCEL,\n\n  mouseup:       END,\n  pointerup:     END,\n  touchend:      END,\n\n  mousemove:   MOVE,\n  pointermove: MOVE,\n  touchmove:   MOVE,\n\n  mousedown:   START,\n  pointerdown: START,\n  touchstart:  START,\n});\n\nmodule.exports = {\n  CANCEL_EVENTS,\n  KEYBOARD_EVENTS,\n  MOUSE_EVENTS,\n  POINTER_EVENTS,\n  TOUCH_EVENTS,\n\n  STATE_KEYS,\n  STATE_KEY_STRINGS,\n\n  CANCEL,\n  END,\n  MOVE,\n  START,\n\n  PHASE,\n};\n\n","'use strict';\n\nconst PI_2   = 2 * Math.PI;\nconst PI_NVE = -Math.PI;\n\n/**\n * Helper function to regulate angular differences, so they don't jump from 0 to\n * 2 * PI or vice versa.\n *\n * @memberof westures-core\n *\n * @param {number} a - Angle in radians.\n * @param {number} b - Angle in radians.\n\n * @return {number} c, given by: c = a - b such that |c| < PI\n */\nfunction angularDifference(a, b) {\n  let diff = a - b;\n  if (diff < PI_NVE) {\n    diff += PI_2;\n  } else if (diff > Math.PI) {\n    diff -= PI_2;\n  }\n  return diff;\n}\n\n/**\n * In case event.composedPath() is not available.\n *\n * @memberof westures-core\n *\n * @param {Event} event\n *\n * @return {Element[]} The elements along the composed path of the event.\n */\nfunction getPropagationPath(event) {\n  if (typeof event.composedPath === 'function') {\n    return event.composedPath();\n  }\n\n  const path = [];\n  for (let node = event.target; node !== document; node = node.parentNode) {\n    path.push(node);\n  }\n  path.push(document);\n  path.push(window);\n\n  return path;\n}\n\n/**\n * Performs a set filter operation.\n *\n * @memberof westures-core\n *\n * @param {Set} set - The set to filter.\n * @param {Function} predicate - Function to test elements of 'set'. Receives\n * one argument: the current set element.\n *\n * @return {Set} Set consisting of elements in 'set' for which 'predicate' is\n * true.\n */\nfunction setFilter(set, predicate) {\n  const result = new Set();\n  set.forEach(element => {\n    if (predicate(element)) {\n      result.add(element);\n    }\n  });\n  return result;\n}\n\n/**\n * Performs a set difference operation.\n *\n * @memberof westures-core\n *\n * @param {Set} left - Base set.\n * @param {Set} right - Set of elements to remove from 'left'.\n *\n * @return {Set} Set consisting of elements in 'left' that are not in\n * 'right'.\n */\nfunction setDifference(left, right) {\n  return setFilter(left, element => !right.has(element));\n}\n\nmodule.exports = Object.freeze({\n  angularDifference,\n  getPropagationPath,\n  setDifference,\n  setFilter,\n});\n\n","'use strict';\n\nconst PointerData = require('./PointerData.js');\nconst { getPropagationPath } = require('./utils.js');\n\n/**\n * Tracks a single input and contains information about the current, previous,\n * and initial events. Contains the progress of each Input and its associated\n * gestures.\n *\n * @memberof westures-core\n *\n * @param {(PointerEvent | MouseEvent | TouchEvent)} event - The input event\n * which will initialize this Input object.\n * @param {number} identifier - The identifier for this input, so that it can\n * be located in subsequent Event objects.\n */\nclass Input {\n  constructor(event, identifier) {\n    const currentData = new PointerData(event, identifier);\n\n    /**\n     * The set of elements along the original event's propagation path at the\n     * time it was dispatched.\n     *\n     * @type {WeakSet.<Element>}\n     */\n    this.initialElements = new WeakSet(getPropagationPath(event));\n\n    /**\n     * Holds the initial data from the mousedown / touchstart / pointerdown that\n     * began this input.\n     *\n     * @type {westures-core.PointerData}\n     */\n    this.initial = currentData;\n\n    /**\n     * Holds the most current pointer data for this Input.\n     *\n     * @type {westures-core.PointerData}\n     */\n    this.current = currentData;\n\n    /**\n     * Holds the previous pointer data for this Input.\n     *\n     * @type {westures-core.PointerData}\n     */\n    this.previous = currentData;\n\n    /**\n     * The identifier for the pointer / touch / mouse button associated with\n     * this input.\n     *\n     * @type {number}\n     */\n    this.identifier = identifier;\n  }\n\n  /**\n   * The phase of the input: 'start' or 'move' or 'end' or 'cancel'\n   *\n   * @type {string}\n   */\n  get phase() { return this.current.type; }\n\n  /**\n   * The timestamp of the initiating event for this input.\n   *\n   * @type {number}\n   */\n  get startTime() { return this.initial.time; }\n\n  /**\n   * @return {number} The distance between the initiating event for this input\n   *    and its current event.\n   */\n  totalDistance() {\n    return this.initial.point.distanceTo(this.current.point);\n  }\n\n  /**\n   * Saves the given raw event in PointerData form as the current data for this\n   * input, pushing the old current data into the previous slot, and tossing\n   * out the old previous data.\n   *\n   * @param {Event} event - The event object to wrap with a PointerData.\n   */\n  update(event) {\n    this.previous = this.current;\n    this.current = new PointerData(event, this.identifier);\n  }\n}\n\nmodule.exports = Input;\n\n","'use strict';\n\nconst {\n  CANCEL,\n  END,\n  MOVE,\n  PHASE,\n  START,\n} = require('./constants.js');\nconst Input     = require('./Input.js');\nconst Point2D   = require('./Point2D.js');\n\nconst symbols = Object.freeze({\n  inputs: Symbol.for('inputs'),\n});\n\n/**\n * Set of helper functions for updating inputs based on type of input.\n * Must be called with a bound 'this', via bind(), or call(), or apply().\n *\n * @private\n * @inner\n * @memberof westure-core.State\n */\nconst update_fns = {\n  TouchEvent: function TouchEvent(event) {\n    Array.from(event.changedTouches).forEach(touch => {\n      this.updateInput(event, touch.identifier);\n    });\n  },\n\n  PointerEvent: function PointerEvent(event) {\n    this.updateInput(event, event.pointerId);\n  },\n\n  MouseEvent: function MouseEvent(event) {\n    if (event.button === 0) {\n      this.updateInput(event, event.button);\n    }\n  },\n};\n\n/**\n * Keeps track of currently active and ending input points on the interactive\n * surface.\n *\n * @memberof westures-core\n *\n * @param {Element} element - The element underpinning the associated Region.\n */\nclass State {\n  constructor(element) {\n    /**\n     * Keep a reference to the element for the associated region.\n     *\n     * @type {Element}\n     */\n    this.element = element;\n\n    /**\n     * Keeps track of the current Input objects.\n     *\n     * @alias [@@inputs]\n     * @type {Map.<westures-core.Input>}\n     * @memberof westure-core.State\n     */\n    this[symbols.inputs] = new Map();\n\n    /**\n     * All currently valid inputs, including those that have ended.\n     *\n     * @type {westures-core.Input[]}\n     */\n    this.inputs = [];\n\n    /**\n     * The array of currently active inputs, sourced from the current Input\n     * objects. \"Active\" is defined as not being in the 'end' phase.\n     *\n     * @type {westures-core.Input[]}\n     */\n    this.active = [];\n\n    /**\n     * The array of latest point data for the currently active inputs, sourced\n     * from this.active.\n     *\n     * @type {westures-core.Point2D[]}\n     */\n    this.activePoints = [];\n\n    /**\n     * The centroid of the currently active points.\n     *\n     * @type {westures-core.Point2D}\n     */\n    this.centroid = {};\n\n    /**\n     * The latest event that the state processed.\n     *\n     * @type {Event}\n     */\n    this.event = null;\n  }\n\n  /**\n   * Deletes all inputs that are in the 'end' phase.\n   */\n  clearEndedInputs() {\n    this[symbols.inputs].forEach((v, k) => {\n      if (v.phase === 'end') this[symbols.inputs].delete(k);\n    });\n  }\n\n  /**\n   * @param {string} phase - One of 'start', 'move', 'end', or 'cancel'.\n   *\n   * @return {westures-core.Input[]} Inputs in the given phase.\n   */\n  getInputsInPhase(phase) {\n    return this.inputs.filter(i => i.phase === phase);\n  }\n\n  /**\n   * @param {string} phase - One of 'start', 'move', 'end', or 'cancel'.\n   *\n   * @return {westures-core.Input[]} Inputs <b>not</b> in the given phase.\n   */\n  getInputsNotInPhase(phase) {\n    return this.inputs.filter(i => i.phase !== phase);\n  }\n\n  /**\n   * @return {boolean} True if there are no active inputs. False otherwise.\n   */\n  hasNoInputs() {\n    return this[symbols.inputs].size === 0;\n  }\n\n  /**\n   * Update the input with the given identifier using the given event.\n   *\n   * @private\n   *\n   * @param {Event} event - The event being captured.\n   * @param {number} identifier - The identifier of the input to update.\n   */\n  updateInput(event, identifier) {\n    switch (PHASE[event.type]) {\n    case START:\n      this[symbols.inputs].set(\n        identifier,\n        new Input(event, identifier),\n      );\n      try {\n        this.element.setPointerCapture(identifier);\n      } catch (e) {\n        // NOP: Optional operation failed.\n      }\n      break;\n\n    // All of 'end', 'move', and 'cancel' perform updates, hence the\n    // following fall-throughs\n    case END:\n      try {\n        this.element.releasePointerCapture(identifier);\n      } catch (e) {\n        // NOP: Optional operation failed.\n      }\n    case CANCEL:\n    case MOVE:\n      if (this[symbols.inputs].has(identifier)) {\n        this[symbols.inputs].get(identifier).update(event);\n      }\n      break;\n\n    default:\n      console.warn(`Unrecognized event type: ${event.type}`);\n    }\n  }\n\n  /**\n   * Updates the inputs with new information based upon a new event being fired.\n   *\n   * @private\n   * @param {Event} event - The event being captured.\n   */\n  updateAllInputs(event) {\n    update_fns[event.constructor.name].call(this, event);\n    this.updateFields(event);\n  }\n\n  /**\n   * Updates the convenience fields.\n   *\n   * @private\n   * @param {Event} event - Event with which to update the convenience fields.\n   */\n  updateFields(event) {\n    this.inputs = Array.from(this[symbols.inputs].values());\n    this.active = this.getInputsNotInPhase('end');\n    this.activePoints = this.active.map(i => i.current.point);\n    this.centroid = Point2D.centroid(this.activePoints);\n    this.event = event;\n  }\n}\n\nmodule.exports = State;\n\n","'use strict';\n\nconst State = require('./State.js');\nconst {\n  CANCEL_EVENTS,\n  KEYBOARD_EVENTS,\n  MOUSE_EVENTS,\n  POINTER_EVENTS,\n  TOUCH_EVENTS,\n\n  STATE_KEY_STRINGS,\n\n  PHASE,\n\n  CANCEL,\n  END,\n  START,\n} = require('./constants.js');\nconst {\n  setDifference,\n  setFilter,\n} = require('./utils.js');\n\n/**\n * Allows the user to specify the control region which will listen for user\n * input events.\n *\n * @memberof westures-core\n *\n * @param {Element} element - The element which should listen to input events.\n * @param {object} [options]\n * @param {boolean} [options.capture=false] - Whether the region uses the\n * capture phase of input events. If false, uses the bubbling phase.\n * @param {boolean} [options.preventDefault=true] - Whether the default\n * browser functionality should be disabled. This option should most likely be\n * ignored. Here there by dragons if set to false.\n */\nclass Region {\n  constructor(element, options = {}) {\n    const settings = { ...Region.DEFAULTS, ...options };\n\n    /**\n     * The list of relations between elements, their gestures, and the handlers.\n     *\n     * @type {Set.<westures-core.Gesture>}\n     */\n    this.gestures = new Set();\n\n    /**\n     * The list of active gestures for the current input session.\n     *\n     * @type {Set.<westures-core.Gesture>}\n     */\n    this.activeGestures = new Set();\n\n    /**\n     * The base list of potentially active gestures for the current input\n     * session.\n     *\n     * @type {Set.<westures-core.Gesture>}\n     */\n    this.potentialGestures = new Set();\n\n    /**\n     * The element being bound to.\n     *\n     * @type {Element}\n     */\n    this.element = element;\n\n    /**\n     * Whether the region listens for captures or bubbles.\n     *\n     * @type {boolean}\n     */\n    this.capture = settings.capture;\n\n    /**\n     * Whether the default browser functionality should be disabled. This option\n     * should most likely be ignored. Here there by dragons if set to false.\n     *\n     * @type {boolean}\n     */\n    this.preventDefault = settings.preventDefault;\n\n    /**\n     * The internal state object for a Region.  Keeps track of inputs.\n     *\n     * @type {westures-core.State}\n     */\n    this.state = new State(this.element);\n\n    // Begin operating immediately.\n    this.activate();\n  }\n\n  /**\n   * Activates the region by adding event listeners for all appropriate input\n   * events to the region's element.\n   *\n   * @private\n   */\n  activate() {\n    /*\n     * Having to listen to both mouse and touch events is annoying, but\n     * necessary due to conflicting standards and browser implementations.\n     * Pointer is a fallback for now instead of the primary, until I figure out\n     * all the details to do with pointer-events and touch-action and their\n     * cross browser compatibility.\n     *\n     * Listening to both mouse and touch comes with the difficulty that\n     * preventDefault() must be called to prevent both events from iterating\n     * through the system. However I have left it as an option to the end user,\n     * which defaults to calling preventDefault(), in case there's a use-case I\n     * haven't considered or am not aware of.\n     *\n     * It is also a good idea to keep regions small in large pages.\n     *\n     * See:\n     *  https://www.html5rocks.com/en/mobile/touchandmouse/\n     *  https://developer.mozilla.org/en-US/docs/Web/API/Touch_events\n     *  https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events\n     */\n    let eventNames = [];\n    if (window.TouchEvent || window.MouseEvent) {\n      eventNames = MOUSE_EVENTS.concat(TOUCH_EVENTS);\n    } else {\n      eventNames = POINTER_EVENTS;\n    }\n\n    // Bind detected browser events to the region element.\n    const arbitrate = this.arbitrate.bind(this);\n    eventNames.forEach(eventName => {\n      this.element.addEventListener(eventName, arbitrate, {\n        capture: this.capture,\n        once:    false,\n        passive: false,\n      });\n    });\n\n    const cancel = this.cancel.bind(this);\n    CANCEL_EVENTS.forEach(eventName => {\n      window.addEventListener(eventName, cancel);\n    });\n\n    const handleKeyboardEvent = this.handleKeyboardEvent.bind(this);\n    KEYBOARD_EVENTS.forEach(eventName => {\n      window.addEventListener(eventName, handleKeyboardEvent);\n    });\n  }\n\n  /**\n   * Handles a cancel event. Resets the state and the active / potential gesture\n   * lists.\n   *\n   * @private\n   * @param {Event} event - The event emitted from the window object.\n   */\n  cancel(event) {\n    event.preventDefault();\n    this.state.inputs.forEach(input => {\n      input.update(event);\n    });\n    this.activeGestures.forEach(gesture => {\n      gesture.evaluateHook(CANCEL, this.state);\n    });\n    this.state = new State(this.element);\n    this.resetActiveGestures();\n  }\n\n  /**\n   * Handles a keyboard event, triggering a restart of any gestures that need\n   * it.\n   *\n   * @private\n   * @param {KeyboardEvent} event - The keyboard event.\n   */\n  handleKeyboardEvent(event) {\n    if (STATE_KEY_STRINGS.indexOf(event.key) >= 0) {\n      this.state.event = event;\n      const oldActiveGestures = this.activeGestures;\n      this.setActiveGestures();\n\n      setDifference(oldActiveGestures, this.activeGestures).forEach(gesture => {\n        gesture.evaluateHook(END, this.state);\n      });\n      setDifference(this.activeGestures, oldActiveGestures).forEach(gesture => {\n        gesture.evaluateHook(START, this.state);\n      });\n    }\n  }\n\n  /**\n   * Resets the active gestures.\n   *\n   * @private\n   */\n  resetActiveGestures() {\n    this.potentialGestures = new Set();\n    this.activeGestures = new Set();\n  }\n\n  /**\n   * Selects active gestures from the list of potentially active gestures.\n   *\n   * @private\n   */\n  setActiveGestures() {\n    this.activeGestures = setFilter(this.potentialGestures, gesture => {\n      return gesture.isEnabled(this.state);\n    });\n  }\n\n  /**\n   * Selects the potentially active gestures.\n   *\n   * @private\n   */\n  setPotentialGestures() {\n    const input = this.state.inputs[0];\n    this.potentialGestures = setFilter(this.gestures, gesture => {\n      return input.initialElements.has(gesture.element);\n    });\n  }\n\n  /**\n   * Selects the gestures that are active for the current input sequence.\n   *\n   * @private\n   * @param {Event} event - The event emitted from the window object.\n   * @param {boolean} isInitial - Whether this is an initial contact.\n   */\n  updateActiveGestures(event, isInitial) {\n    if (PHASE[event.type] === START) {\n      if (isInitial) {\n        this.setPotentialGestures();\n      }\n      this.setActiveGestures();\n    }\n  }\n\n  /**\n   * Evaluates whether the current input session has completed.\n   *\n   * @private\n   * @param {Event} event - The event emitted from the window object.\n   */\n  pruneActiveGestures(event) {\n    if (PHASE[event.type] === END) {\n      if (this.state.hasNoInputs()) {\n        this.resetActiveGestures();\n      } else {\n        this.setActiveGestures();\n      }\n    }\n  }\n\n  /**\n   * All input events flow through this function. It makes sure that the input\n   * state is maintained, determines which gestures to analyze based on the\n   * initial position of the inputs, calls the relevant gesture hooks, and\n   * dispatches gesture data.\n   *\n   * @private\n   * @param {Event} event - The event emitted from the window object.\n   */\n  arbitrate(event) {\n    const isInitial = this.state.hasNoInputs();\n    this.state.updateAllInputs(event);\n    this.updateActiveGestures(event, isInitial);\n\n    if (this.activeGestures.size > 0) {\n      if (this.preventDefault) event.preventDefault();\n\n      this.activeGestures.forEach(gesture => {\n        gesture.evaluateHook(PHASE[event.type], this.state);\n      });\n    }\n\n    this.state.clearEndedInputs();\n    this.pruneActiveGestures(event);\n  }\n\n  /**\n   * Adds the given gesture to the region.\n   *\n   * @param {westures-core.Gesture} gesture - Instantiated gesture to add.\n   */\n  addGesture(gesture) {\n    this.gestures.add(gesture);\n  }\n\n  /**\n   * Removes the given gesture from the region.\n   *\n   * @param {westures-core.Gesture} gesture - Instantiated gesture to add.\n   */\n  removeGesture(gesture) {\n    this.gestures.delete(gesture);\n    this.potentialGestures.delete(gesture);\n    this.activeGestures.delete(gesture);\n  }\n\n  /**\n   * Retrieves Gestures by their associated element.\n   *\n   * @param {Element} element - The element for which to find gestures.\n   *\n   * @return {westures-core.Gesture[]} Gestures to which the element is bound.\n   */\n  getGesturesByElement(element) {\n    return setFilter(this.gestures, gesture => gesture.element === element);\n  }\n\n  /**\n   * Remove all gestures bound to the given element.\n   *\n   * @param {Element} element - The element to unbind.\n   */\n  removeGesturesByElement(element) {\n    this.getGesturesByElement(element).forEach(g => this.removeGesture(g));\n  }\n}\n\nRegion.DEFAULTS = Object.freeze({\n  capture:        false,\n  preventDefault: true,\n});\n\nmodule.exports = Region;\n\n","'use strict';\n\nconst cascade = Symbol('cascade');\nconst smooth = Symbol('smooth');\n\n/**\n * Determines whether to apply smoothing. Smoothing is on by default but turned\n * off if either:<br>\n *  1. The user explicitly requests that it be turned off.<br>\n *  2. The active pointer is not \"coarse\".<br>\n *\n * @see {@link\n * https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia}\n *\n * @inner\n * @memberof westures-core.Smoothable\n *\n * @param {boolean} isRequested - Whether smoothing was requested by the user.\n *\n * @returns {boolean} Whether to apply smoothing.\n */\nfunction smoothingIsApplicable(isRequested) {\n  if (isRequested) {\n    try {\n      return window.matchMedia('(pointer: coarse)').matches;\n    } catch (e) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * A Smoothable datatype is one that is capable of smoothing out a series of\n * values as they come in, one at a time, providing a more consistent series. It\n * does this by creating some inertia in the values using a cascading average.\n * (For those who are interested in such things, this effectively means that it\n * provides a practical application of Zeno's Dichotomy).\n *\n * @example\n * const x = new Smoothable({ identity: 1 });\n * const a = x.next(1);   // 1.0\n * const b = x.next(1.2); // 1.1\n * const c = x.next(0.9); // 1.0\n * const d = x.next(0.6); // 0.8\n * const e = x.next(1.2); // 1.0\n * const f = x.next(1.6); // 1.3\n * x.restart();\n * const g = x.next(0);   // 0.5\n *\n * @memberof westures-core\n *\n * @param {Object} [options]\n * @param {boolean} [options.applySmoothing=true] Whether to apply smoothing to\n * the data.\n * @param {*} [options.identity=0] The identity value of this smoothable data.\n */\nclass Smoothable {\n  constructor(options = {}) {\n    const final_options = { ...Smoothable.DEFAULTS, ...options };\n\n    /**\n     * The function through which smoothed emits are passed.\n     *\n     * @method\n     * @param {*} data - The data to emit.\n     *\n     * @return {*} The smoothed out data.\n     */\n    this.next = null;\n    if (smoothingIsApplicable(final_options.applySmoothing)) {\n      this.next = this[smooth].bind(this);\n    } else {\n      this.next = data => data;\n    }\n\n    /**\n     * The \"identity\" value of the data that will be smoothed.\n     *\n     * @type {*}\n     * @default 0\n     */\n    this.identity = final_options.identity;\n\n    /**\n     * The cascading average of outgoing values.\n     *\n     * @memberof westures-core.Smoothable\n     * @alias [@@cascade]\n     * @type {object}\n     */\n    this[cascade] = this.identity;\n  }\n\n  /**\n   * Restart the Smoothable gesture.\n   */\n  restart() {\n    this[cascade] = this.identity;\n  }\n\n  /**\n   * Smooth out the outgoing data.\n   *\n   * @memberof westures-core.Smoothable\n   * @alias [@@smooth]\n   * @param {object} data - The next batch of data to emit.\n   *\n   * @return {?object}\n   */\n  [smooth](data) {\n    const average = this.average(this[cascade], data);\n    this[cascade] = average;\n    return average;\n  }\n\n  /**\n   * Average out two values, as part of the smoothing algorithm. Override this\n   * method if the data being smoothed is not a Number.\n   *\n   * @param {number} a\n   * @param {number} b\n   *\n   * @return {number} The average of 'a' and 'b'\n   */\n  average(a, b) {\n    return (a + b) / 2;\n  }\n}\n\nSmoothable.DEFAULTS = Object.freeze({\n  applySmoothing: true,\n  identity:       0,\n});\n\nmodule.exports = Smoothable;\n\n","/*\n * Contains the Pan class.\n */\n\n'use strict';\n\nconst { Gesture, Point2D, Smoothable } = require('westures-core');\n\n/**\n * Data returned when a Pan is recognized.\n *\n * @typedef {Object} PanData\n * @mixes ReturnTypes.BaseData\n *\n * @property {westures-core.Point2D} translation - The change vector from the\n * last emit.\n *\n * @memberof ReturnTypes\n */\n\n/**\n * A Pan is defined as a normal movement in any direction.\n *\n * @extends westures-core.Gesture\n * @see {ReturnTypes.PanData}\n * @see {westures-core.Smoothable}\n * @memberof westures\n *\n * @param {Element} element - The element with which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n * is recognized on the associated element.\n * @param {object} [options] - Gesture customization options.\n * @param {westures-core.STATE_KEYS[]} [options.enableKeys=[]] - List of keys\n * which will enable the gesture. The gesture will not be recognized unless one\n * of these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the enable key is always down.\n * @param {westures-core.STATE_KEYS[]} [options.disableKeys=[]] - List of keys\n * which will disable the gesture. The gesture will not be recognized if one of\n * these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the disable key is never down.\n * @param {number} [options.minInputs=1] - The minimum number of pointers that\n * must be active for the gesture to be recognized. Uses >=.\n * @param {number} [options.maxInputs=Number.MAX_VALUE] - The maximum number of\n * pointers that may be active for the gesture to be recognized. Uses <=.\n * @param {boolean} [options.applySmoothing=true] - Whether to apply inertial\n * smoothing for systems with coarse pointers.\n */\nclass Pan extends Gesture {\n  constructor(element, handler, options = {}) {\n    super('pan', element, handler, options);\n\n    /**\n     * The previous point location.\n     *\n     * @type {westures-core.Point2D}\n     */\n    this.previous = null;\n\n    /*\n     * The outgoing data, with optional inertial smoothing.\n     *\n     * @override\n     * @type {westures-core.Smoothable<westures-core.Point2D>}\n     */\n    this.outgoing = new Smoothable({ ...options, identity: new Point2D() });\n    this.outgoing.average = (a, b) => Point2D.centroid([a, b]);\n  }\n\n  /**\n   * Resets the gesture's progress by saving the current centroid of the active\n   * inputs. To be called whenever the number of inputs changes.\n   *\n   * @param {State} state\n   */\n  restart(state) {\n    this.previous = state.centroid;\n    this.outgoing.restart();\n  }\n\n  start(state) {\n    this.restart(state);\n  }\n\n  move(state) {\n    const translation = state.centroid.minus(this.previous);\n    this.previous = state.centroid;\n    return { translation: this.outgoing.next(translation) };\n  }\n\n  end(state) {\n    this.restart(state);\n  }\n\n  cancel(state) {\n    this.restart(state);\n  }\n}\n\nmodule.exports = Pan;\n\n","/**\n * The global API interface for westures-core. Exposes all classes, constants,\n * and routines used by the package. Use responsibly.\n *\n * @namespace westures-core\n */\n\n'use strict';\n\nconst Gesture = require('./src/Gesture.js');\nconst Input = require('./src/Input.js');\nconst Point2D = require('./src/Point2D.js');\nconst PointerData = require('./src/PointerData.js');\nconst Region = require('./src/Region.js');\nconst Smoothable = require('./src/Smoothable.js');\nconst State = require('./src/State.js');\nconst constants = require('./src/constants.js');\nconst utils = require('./src/utils.js');\n\nmodule.exports = {\n  Gesture,\n  Input,\n  Point2D,\n  PointerData,\n  Region,\n  Smoothable,\n  State,\n  ...constants,\n  ...utils,\n};\n\n","/*\n * Contains the abstract Pinch class.\n */\n\n'use strict';\n\nconst { Gesture, Smoothable } = require('westures-core');\n\n/**\n * Data returned when a Pinch is recognized.\n *\n * @typedef {Object} PinchData\n * @mixes ReturnTypes.BaseData\n *\n * @property {number} distance - The average distance from an active input to\n *    the centroid.\n * @property {number} scale - The proportional change in distance since last\n * emit.\n *\n * @memberof ReturnTypes\n */\n\n/**\n * A Pinch is defined as two or more inputs moving either together or apart.\n *\n * @extends westures-core.Gesture\n * @see {ReturnTypes.PinchData}\n * @memberof westures\n *\n * @param {Element} element - The element to which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n * is recognized on the associated element.\n * @param {object} [options] - Gesture customization options.\n * @param {westures-core.STATE_KEYS[]} [options.enableKeys=[]] - List of keys\n * which will enable the gesture. The gesture will not be recognized unless one\n * of these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the enable key is always down.\n * @param {westures-core.STATE_KEYS[]} [options.disableKeys=[]] - List of keys\n * which will disable the gesture. The gesture will not be recognized if one of\n * these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the disable key is never down.\n * @param {number} [options.minInputs=2] - The minimum number of pointers that\n * must be active for the gesture to be recognized. Uses >=.\n * @param {number} [options.maxInputs=Number.MAX_VALUE] - The maximum number of\n * pointers that may be active for the gesture to be recognized. Uses <=.\n * @param {boolean} [options.applySmoothing=true] - Whether to apply inertial\n * smoothing for systems with coarse pointers.\n */\nclass Pinch extends Gesture {\n  constructor(element, handler, options = {}) {\n    options = { ...Pinch.DEFAULTS, ...options };\n    super('pinch', element, handler, options);\n\n    /**\n     * The previous distance.\n     *\n     * @type {number}\n     */\n    this.previous = 0;\n\n    /*\n     * The outgoing data, with optional inertial smoothing.\n     *\n     * @override\n     * @type {westures-core.Smoothable<number>}\n     */\n    this.outgoing = new Smoothable({ ...options, identity: 1 });\n  }\n\n  /**\n   * Initializes the gesture progress.\n   *\n   * @param {State} state - current input state.\n   */\n  restart(state) {\n    this.previous = state.centroid.averageDistanceTo(state.activePoints);\n    this.outgoing.restart();\n  }\n\n  start(state) {\n    this.restart(state);\n  }\n\n  move(state) {\n    const distance = state.centroid.averageDistanceTo(state.activePoints);\n    const scale = distance / this.previous;\n    this.previous = distance;\n    return { distance, scale: this.outgoing.next(scale) };\n  }\n\n  end(state) {\n    this.restart(state);\n  }\n\n  cancel(state) {\n    this.restart(state);\n  }\n}\n\nPinch.DEFAULTS = Object.freeze({\n  minInputs: 2,\n});\n\nmodule.exports = Pinch;\n\n","/*\n * Contains the Press class.\n */\n\n'use strict';\n\nconst { Gesture, Point2D, MOVE } = require('westures-core');\n\n/**\n * Data returned when a Press is recognized.\n *\n * @typedef {Object} PressData\n *\n * @property {westures-core.Point2D} centroid - The current centroid of the\n * input points.\n * @property {westures-core.Point2D} initial - The initial centroid of the input\n * points.\n * @property {number} distance - The total movement since initial contact.\n *\n * @memberof ReturnTypes\n */\n\n/**\n * A Press is defined as one or more input points being held down without\n * moving. Press gestures may be stacked by pressing with additional pointers\n * beyond the minimum, so long as none of the points move or are lifted, a Press\n * will be recognized for each additional pointer.\n *\n * @extends westures-core.Gesture\n * @see {ReturnTypes.PressData}\n * @memberof westures\n *\n * @param {Element} element - The element to which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n * is recognized on the associated element.\n * @param {object} [options] - Gesture customization options.\n * @param {westures-core.STATE_KEYS[]} [options.enableKeys=[]] - List of keys\n * which will enable the gesture. The gesture will not be recognized unless one\n * of these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the enable key is always down.\n * @param {westures-core.STATE_KEYS[]} [options.disableKeys=[]] - List of keys\n * which will disable the gesture. The gesture will not be recognized if one of\n * these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the disable key is never down.\n * @param {number} [options.minInputs=1] - The minimum number of pointers that\n * must be active for the gesture to be recognized. Uses >=.\n * @param {number} [options.maxInputs=Number.MAX_VALUE] - The maximum number of\n * pointers that may be active for the gesture to be recognized. Uses <=.\n * @param {number} [options.delay=1000] - The delay before emitting, during\n * which time the number of inputs must not go below minInputs.\n * @param {number} [options.tolerance=10] - The tolerance in pixels a user can\n * move and still allow the gesture to emit.\n */\nclass Press extends Gesture {\n  constructor(element, handler, options = {}) {\n    options = { ...Press.DEFAULTS, ...options };\n    super('press', element, handler, options);\n\n    /**\n     * The delay before emitting a press event, during which time the number of\n     * inputs must not change.\n     *\n     * @type {number}\n     */\n    this.delay = options.delay;\n\n    /**\n     * A move tolerance in pixels allows some slop between a user's start to end\n     * events. This allows the Press gesture to be triggered more easily.\n     *\n     * @type {number}\n     */\n    this.tolerance = options.tolerance;\n  }\n\n  start(state) {\n    const initial = state.centroid;\n    const identifiers = new Set(state.active.map(i => i.identifier));\n    setTimeout(() => {\n      const inputs = state.active.filter(i => identifiers.has(i.identifier));\n      const centroid = Point2D.centroid(inputs.map(i => i.current.point));\n      const distance = initial.distanceTo(centroid);\n      if (distance <= this.tolerance && inputs.length === identifiers.size) {\n        this.recognize(MOVE, state, { centroid, distance, initial });\n      }\n    }, this.delay);\n  }\n}\n\nPress.DEFAULTS = Object.freeze({\n  delay:     1000,\n  tolerance: 10,\n});\n\nmodule.exports = Press;\n\n","/*\n * Contains the abstract Pull class.\n */\n\n'use strict';\n\nconst { Smoothable } = require('westures-core');\nconst Pivotable = require('./Pivotable.js');\n\n/**\n * Data returned when a Pull is recognized.\n *\n * @typedef {Object} PullData\n * @mixes ReturnTypes.BaseData\n *\n * @property {number} distance - The average distance from an active input to\n * the centroid.\n * @property {number} scale - The proportional change in distance since last\n * emit.\n * @property {westures-core.Point2D} pivot - The pivot point.\n *\n * @memberof ReturnTypes\n */\n\n/**\n * A Pull is defined as a single input moving away from or towards a pivot\n * point.\n *\n * @extends westures-core.Gesture\n * @see {ReturnTypes.PullData}\n * @memberof westures\n *\n * @param {Element} element - The element to which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n * is recognized on the associated element.\n * @param {object} [options] - Gesture customization options.\n * @param {westures-core.STATE_KEYS[]} [options.enableKeys=[]] - List of keys\n * which will enable the gesture. The gesture will not be recognized unless one\n * of these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the enable key is always down.\n * @param {westures-core.STATE_KEYS[]} [options.disableKeys=[]] - List of keys\n * which will disable the gesture. The gesture will not be recognized if one of\n * these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the disable key is never down.\n * @param {number} [options.minInputs=1] - The minimum number of pointers that\n * must be active for the gesture to be recognized. Uses >=.\n * @param {number} [options.maxInputs=Number.MAX_VALUE] - The maximum number of\n * pointers that may be active for the gesture to be recognized. Uses <=.\n * @param {boolean} [options.applySmoothing=true] - Whether to apply inertial\n * smoothing for systems with coarse pointers.\n * @param {number} [options.deadzoneRadius=15] - The radius in pixels around the\n * start point in which to do nothing.\n * @param {Element} [options.dynamicPivot=false] - Normally the center point of\n * the gesture's element is used as the pivot. If this option is set, the\n * initial contact point with the element is used as the pivot instead.\n */\nclass Pull extends Pivotable {\n  constructor(element, handler, options = {}) {\n    super('pull', element, handler, options);\n\n    /*\n     * The outgoing data, with optional inertial smoothing.\n     *\n     * @override\n     * @type {westures-core.Smoothable<number>}\n     */\n    this.outgoing = new Smoothable({ ...options, identity: 1 });\n  }\n\n  updatePrevious(state) {\n    this.previous = this.pivot.distanceTo(state.centroid);\n  }\n\n  move(state) {\n    const pivot = this.pivot;\n    const distance = pivot.distanceTo(state.centroid);\n    const scale = distance / this.previous;\n\n    let rv = null;\n    if (distance > this.deadzoneRadius && this.previous > this.deadzoneRadius) {\n      rv = { distance, scale: this.outgoing.next(scale), pivot };\n    }\n\n    /*\n     * Updating the previous distance regardless of emit prevents sudden changes\n     * when the user exits the deadzone circle.\n     */\n    this.previous = distance;\n\n    return rv;\n  }\n}\n\nmodule.exports = Pull;\n\n","/*\n * Contains the Rotate class.\n */\n\n'use strict';\n\nconst { Gesture, Point2D, Smoothable } = require('westures-core');\n\n/**\n * Data returned when a Pivotable is recognized.\n *\n * @typedef {Object} SwivelData\n * @mixes ReturnTypes.BaseData\n *\n * @property {number} rotation - In radians, the change in angle since last\n * emit.\n * @property {westures-core.Point2D} pivot - The pivot point.\n *\n * @memberof ReturnTypes\n */\n\n/**\n * Determine the center point of the given element's bounding client rectangle.\n *\n * @inner\n * @memberof westures.Pivotable\n *\n * @param {Element} element - The DOM element to analyze.\n * @return {westures-core.Point2D} - The center of the element's bounding client\n * rectangle.\n */\nfunction getClientCenter(element) {\n  const rect = element.getBoundingClientRect();\n  return new Point2D(\n    rect.left + (rect.width / 2),\n    rect.top + (rect.height / 2),\n  );\n}\n\n/**\n * A Pivotable is a single input rotating around a fixed point. The fixed point\n * is determined by the input's location at its 'start' phase.\n *\n * @extends westures.Gesture\n * @see {ReturnTypes.SwivelData}\n * @memberof westures\n *\n * @param {Element} element - The element to which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n * is recognized on the associated element.\n * @param {object} [options] - Gesture customization options.\n * @param {westures-core.STATE_KEYS[]} [options.enableKeys=[]] - List of keys\n * which will enable the gesture. The gesture will not be recognized unless one\n * of these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the enable key is always down.\n * @param {westures-core.STATE_KEYS[]} [options.disableKeys=[]] - List of keys\n * which will disable the gesture. The gesture will not be recognized if one of\n * these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the disable key is never down.\n * @param {number} [options.minInputs=1] - The minimum number of pointers that\n * must be active for the gesture to be recognized. Uses >=.\n * @param {number} [options.maxInputs=Number.MAX_VALUE] - The maximum number of\n * pointers that may be active for the gesture to be recognized. Uses <=.\n * @param {boolean} [options.applySmoothing=true] - Whether to apply inertial\n * smoothing for systems with coarse pointers.\n * @param {number} [options.deadzoneRadius=15] - The radius in pixels around the\n * start point in which to do nothing.\n * @param {Element} [options.dynamicPivot=false] - Normally the center point of\n * the gesture's element is used as the pivot. If this option is set, the\n * initial contact point with the element is used as the pivot instead.\n */\nclass Pivotable extends Gesture {\n  constructor(type = 'pivotable', element, handler, options = {}) {\n    super(type, element, handler, options);\n    options = { ...Pivotable.DEFAULTS, ...options };\n\n    /**\n     * The radius around the start point in which to do nothing.\n     *\n     * @type {number}\n     */\n    this.deadzoneRadius = options.deadzoneRadius;\n\n    /**\n     * Normally the center point of the gesture's element is used as the pivot.\n     * If this option is set, the initial contact point with the element is used\n     * as the pivot instead.\n     *\n     * @type {boolean}\n     */\n    this.dynamicPivot = options.dynamicPivot;\n\n    /**\n     * The pivot point of the pivotable.\n     *\n     * @type {westures-core.Point2D}\n     */\n    this.pivot = null;\n\n    /**\n     * The previous data.\n     *\n     * @type {number}\n     */\n    this.previous = 0;\n\n    /**\n     * The outgoing data.\n     *\n     * @type {westures-core.Smoothable}\n     */\n    this.outgoing = new Smoothable(options);\n  }\n\n  /**\n   * Updates the previous data. It will be called during the 'start' and 'end'\n   * phases, and should also be called during the 'move' phase implemented by\n   * the subclass.\n   *\n   * @abstract\n   * @param {State} state - the current input state.\n   */\n  updatePrevious() {\n    throw 'Gestures which extend Pivotable must implement updatePrevious()';\n  }\n\n  /**\n   * Restart the given progress object using the given input object.\n   *\n   * @param {State} state - current input state.\n   */\n  restart(state) {\n    if (this.dynamicPivot) {\n      this.pivot = state.centroid;\n      this.previous = 0;\n    } else {\n      this.pivot = getClientCenter(this.element);\n      this.updatePrevious(state);\n    }\n    this.outgoing.restart();\n  }\n\n  start(state) {\n    this.restart(state);\n  }\n\n  end(state) {\n    if (state.active.length > 0) {\n      this.restart(state);\n    } else {\n      this.outgoing.restart();\n    }\n  }\n\n  cancel() {\n    this.outgoing.restart();\n  }\n}\n\nPivotable.DEFAULTS = Object.freeze({\n  deadzoneRadius: 15,\n  dynamicPivot:   false,\n});\n\nPivotable.getClientCenter = getClientCenter;\n\nmodule.exports = Pivotable;\n\n","/*\n * Contains the Rotate class.\n */\n\n'use strict';\n\nconst { angularDifference, Gesture, Smoothable } = require('westures-core');\n\n/**\n * Data returned when a Rotate is recognized.\n *\n * @typedef {Object} RotateData\n * @mixes ReturnTypes.BaseData\n *\n * @property {number} rotation - In radians, the change in angle since last\n * emit.\n *\n * @memberof ReturnTypes\n */\n\n/**\n * A Rotate is defined as two inputs moving with a changing angle between them.\n *\n * @extends westures-core.Gesture\n * @see {ReturnTypes.RotateData}\n * @memberof westures\n *\n * @param {Element} element - The element to which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n * is recognized on the associated element.\n * @param {object} [options] - Gesture customization options.\n * @param {westures-core.STATE_KEYS[]} [options.enableKeys=[]] - List of keys\n * which will enable the gesture. The gesture will not be recognized unless one\n * of these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the enable key is always down.\n * @param {westures-core.STATE_KEYS[]} [options.disableKeys=[]] - List of keys\n * which will disable the gesture. The gesture will not be recognized if one of\n * these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the disable key is never down.\n * @param {number} [options.minInputs=2] - The minimum number of pointers that\n * must be active for the gesture to be recognized. Uses >=.\n * @param {number} [options.maxInputs=Number.MAX_VALUE] - The maximum number of\n * pointers that may be active for the gesture to be recognized. Uses <=.\n * @param {boolean} [options.applySmoothing=true] - Whether to apply inertial\n * smoothing for systems with coarse pointers.\n */\nclass Rotate extends Gesture {\n  constructor(element, handler, options = {}) {\n    options = { ...Rotate.DEFAULTS, ...options };\n    super('rotate', element, handler, options);\n\n    /**\n     * Track the previous angles for each input.\n     *\n     * @type {number[]}\n     */\n    this.previousAngles = [];\n\n    /*\n     * The outgoing data, with optional inertial smoothing.\n     *\n     * @override\n     * @type {westures-core.Smoothable<number>}\n     */\n    this.outgoing = new Smoothable(options);\n  }\n\n  /**\n   * Determine the angle from the state's centroid to each of the active inputs.\n   *\n   * @param {State} state - current input state.\n   * @returns {number[]}\n   */\n  anglesFromCentroid(state) {\n    return state.active.map((i) => state.centroid.angleTo(i.current.point));\n  }\n\n  /**\n   * Calculate the per-input angle progress.\n   *\n   * @param {State} state - current input state.\n   * @returns {number} The average change in angle.\n   */\n  getRotation(state) {\n    const stagedAngles = this.anglesFromCentroid(state);\n    const angle = stagedAngles.reduce((total, current, index) => {\n      return total + angularDifference(current, this.previousAngles[index]);\n    }, 0);\n    this.previousAngles = stagedAngles;\n    return angle / state.active.length;\n  }\n\n  /**\n   * Restart the gesture for a new number of inputs.\n   *\n   * @param {State} state - current input state.\n   */\n  restart(state) {\n    this.previousAngles = this.anglesFromCentroid(state);\n    this.outgoing.restart();\n  }\n\n  start(state) {\n    this.restart(state);\n  }\n\n  move(state) {\n    const rotation = this.getRotation(state);\n    return rotation ? { rotation: this.outgoing.next(rotation) } : null;\n  }\n\n  end(state) {\n    this.restart(state);\n  }\n\n  cancel() {\n    this.outgoing.restart();\n  }\n}\n\nRotate.DEFAULTS = Object.freeze({\n  minInputs: 2,\n});\n\nmodule.exports = Rotate;\n\n","/*\n * Contains the Swipe class.\n */\n\n'use strict';\n\nconst { Gesture } = require('westures-core');\n\nconst PROGRESS_STACK_SIZE = 7;\nconst MS_THRESHOLD = 300;\n\n/**\n * Data returned when a Swipe is recognized.\n *\n * @typedef {Object} SwipeData\n * @mixes ReturnTypes.BaseData\n *\n * @property {number} velocity - The velocity of the swipe.\n * @property {number} direction - In radians, the direction of the swipe.\n * @property {westures-core.Point2D} point - The point at which the swipe ended.\n * @property {number} time - The epoch time, in ms, when the swipe ended.\n *\n * @memberof ReturnTypes\n */\n\n/**\n * Calculates the angle of movement along a series of moves.\n *\n * @inner\n * @memberof westures.Swipe\n * @see {@link https://en.wikipedia.org/wiki/Mean_of_circular_quantities}\n *\n * @param {{time: number, point: westures-core.Point2D}} moves - The moves list\n * to process.\n * @param {number} vlim - The number of moves to process.\n *\n * @return {number} The angle of the movement.\n */\nfunction calc_angle(moves, vlim) {\n  const point = moves[vlim].point;\n  let sin = 0;\n  let cos = 0;\n  for (let i = 0; i < vlim; ++i) {\n    const angle = moves[i].point.angleTo(point);\n    sin += Math.sin(angle);\n    cos += Math.cos(angle);\n  }\n  sin /= vlim;\n  cos /= vlim;\n  return Math.atan2(sin, cos);\n}\n\n/**\n * Local helper function for calculating the velocity between two timestamped\n * points.\n *\n * @inner\n * @memberof westures.Swipe\n *\n * @param {object} start\n * @param {westures-core.Point2D} start.point\n * @param {number} start.time\n * @param {object} end\n * @param {westures-core.Point2D} end.point\n * @param {number} end.time\n *\n * @return {number} velocity from start to end point.\n */\nfunction velocity(start, end) {\n  const distance = end.point.distanceTo(start.point);\n  const time = end.time - start.time + 1;\n  return distance / time;\n}\n\n/**\n * Calculates the veloctiy of movement through a series of moves.\n *\n * @inner\n * @memberof westures.Swipe\n *\n * @param {{time: number, point: westures-core.Point2D}} moves - The moves list\n * to process.\n * @param {number} vlim - The number of moves to process.\n *\n * @return {number} The velocity of the moves.\n */\nfunction calc_velocity(moves, vlim) {\n  let max = 0;\n  for (let i = 0; i < vlim; ++i) {\n    const current = velocity(moves[i], moves[i + 1]);\n    if (current > max) max = current;\n  }\n  return max;\n}\n\n/**\n * A swipe is defined as input(s) moving in the same direction in an relatively\n * increasing velocity and leaving the screen at some point before it drops\n * below it's escape velocity.\n *\n * @extends westures-core.Gesture\n * @see {ReturnTypes.SwipeData}\n * @memberof westures\n *\n * @param {Element} element - The element to which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n * is recognized on the associated element.\n * @param {object} [options] - Gesture customization options.\n * @param {westures-core.STATE_KEYS[]} [options.enableKeys=[]] - List of keys\n * which will enable the gesture. The gesture will not be recognized unless one\n * of these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the enable key is always down.\n * @param {westures-core.STATE_KEYS[]} [options.disableKeys=[]] - List of keys\n * which will disable the gesture. The gesture will not be recognized if one of\n * these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the disable key is never down.\n * @param {number} [options.minInputs=1] - The minimum number of pointers that\n * must be active for the gesture to be recognized. Uses >=.\n * @param {number} [options.maxInputs=Number.MAX_VALUE] - The maximum number of\n * pointers that may be active for the gesture to be recognized. Uses <=.\n */\nclass Swipe extends Gesture {\n  constructor(element, handler, options = {}) {\n    super('swipe', element, handler, options);\n\n    /**\n     * Moves list.\n     *\n     * @type {object[]}\n     */\n    this.moves = [];\n\n    /**\n     * Data to emit when all points have ended.\n     *\n     * @type {ReturnTypes.SwipeData}\n     */\n    this.saved = null;\n  }\n\n  /**\n   * Restart the swipe state for a new numper of inputs.\n   */\n  restart() {\n    this.moves = [];\n    this.saved = null;\n  }\n\n  start() {\n    this.restart();\n  }\n\n  move(state) {\n    this.moves.push({\n      time:  Date.now(),\n      point: state.centroid,\n    });\n\n    if (this.moves.length > PROGRESS_STACK_SIZE) {\n      this.moves.splice(0, this.moves.length - PROGRESS_STACK_SIZE);\n    }\n  }\n\n  end(state) {\n    const result = this.getResult();\n    this.moves = [];\n\n    if (state.active.length > 0) {\n      this.saved = result;\n      return null;\n    }\n\n    this.saved = null;\n    return this.validate(result);\n  }\n\n  cancel() {\n    this.restart();\n  }\n\n  /**\n   * Get the swipe result.\n   *\n   * @returns {?ReturnTypes.SwipeData}\n   */\n  getResult() {\n    if (this.moves.length < PROGRESS_STACK_SIZE) {\n      return this.saved;\n    }\n    const vlim = PROGRESS_STACK_SIZE - 1;\n    const { point, time } = this.moves[vlim];\n    const velocity = calc_velocity(this.moves, vlim);\n    const direction = calc_angle(this.moves, vlim);\n    const centroid = point;\n    return { point, velocity, direction, time, centroid };\n  }\n\n  /**\n   * Validates that an emit should occur with the given data.\n   *\n   * @param {?ReturnTypes.SwipeData} data\n   * @returns {?ReturnTypes.SwipeData}\n   */\n  validate(data) {\n    if (data == null) return null;\n    return (Date.now() - data.time > MS_THRESHOLD) ? null : data;\n  }\n}\n\nmodule.exports = Swipe;\n\n","/*\n * Contains the Rotate class.\n */\n\n'use strict';\n\nconst { angularDifference, Smoothable } = require('westures-core');\nconst Pivotable = require('./Pivotable.js');\n\n/**\n * Data returned when a Swivel is recognized.\n *\n * @typedef {Object} SwivelData\n * @mixes ReturnTypes.BaseData\n *\n * @property {number} rotation - In radians, the change in angle since last\n * emit.\n * @property {westures-core.Point2D} pivot - The pivot point.\n *\n * @memberof ReturnTypes\n */\n\n/**\n * A Swivel is a single input rotating around a fixed point. The fixed point is\n * determined by the input's location at its 'start' phase.\n *\n * @extends westures-core.Gesture\n * @see {ReturnTypes.SwivelData}\n * @memberof westures\n *\n * @param {Element} element - The element to which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n * is recognized on the associated element.\n * @param {object} [options] - Gesture customization options.\n * @param {westures-core.STATE_KEYS[]} [options.enableKeys=[]] - List of keys\n * which will enable the gesture. The gesture will not be recognized unless one\n * of these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the enable key is always down.\n * @param {westures-core.STATE_KEYS[]} [options.disableKeys=[]] - List of keys\n * which will disable the gesture. The gesture will not be recognized if one of\n * these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the disable key is never down.\n * @param {number} [options.minInputs=1] - The minimum number of pointers that\n * must be active for the gesture to be recognized. Uses >=.\n * @param {number} [options.maxInputs=Number.MAX_VALUE] - The maximum number of\n * pointers that may be active for the gesture to be recognized. Uses <=.\n * @param {boolean} [options.applySmoothing=true] - Whether to apply inertial\n * smoothing for systems with coarse pointers.\n * @param {number} [options.deadzoneRadius=15] - The radius in pixels around the\n * start point in which to do nothing.\n * @param {Element} [options.dynamicPivot=false] - Normally the center point of\n * the gesture's element is used as the pivot. If this option is set, the\n * initial contact point with the element is used as the pivot instead.\n */\nclass Swivel extends Pivotable {\n  constructor(element, handler, options = {}) {\n    super('swivel', element, handler, options);\n\n    /*\n     * The outgoing data, with optional inertial smoothing.\n     *\n     * @override\n     * @type {westures-core.Smoothable<number>}\n     */\n    this.outgoing = new Smoothable(options);\n  }\n\n  updatePrevious(state) {\n    this.previous = this.pivot.angleTo(state.centroid);\n  }\n\n  move(state) {\n    const pivot = this.pivot;\n    const angle = pivot.angleTo(state.centroid);\n    const rotation = angularDifference(angle, this.previous);\n\n    let rv = null;\n    if (pivot.distanceTo(state.centroid) > this.deadzoneRadius) {\n      rv = { rotation: this.outgoing.next(rotation), pivot };\n    }\n\n    /*\n     * Updating the previous angle regardless of emit prevents sudden flips when\n     * the user exits the deadzone circle.\n     */\n    this.previous = angle;\n\n    return rv;\n  }\n}\n\nmodule.exports = Swivel;\n\n","/*\n * Contains the Tap class.\n */\n\n'use strict';\n\nconst { Gesture, Point2D } = require('westures-core');\n\n/**\n * Data returned when a Tap is recognized.\n *\n * @typedef {Object} TapData\n * @mixes ReturnTypes.BaseData\n *\n * @property {number} x - x coordinate of tap point.\n * @property {number} y - y coordinate of tap point.\n *\n * @memberof ReturnTypes\n */\n\n/**\n * A Tap is defined as a touchstart to touchend event in quick succession.\n *\n * @extends westures-core.Gesture\n * @see {ReturnTypes.TapData}\n * @memberof westures\n *\n * @param {Element} element - The element to which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n * is recognized on the associated element.\n * @param {object} [options] - Gesture customization options.\n * @param {westures-core.STATE_KEYS[]} [options.enableKeys=[]] - List of keys\n * which will enable the gesture. The gesture will not be recognized unless one\n * of these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the enable key is always down.\n * @param {westures-core.STATE_KEYS[]} [options.disableKeys=[]] - List of keys\n * which will disable the gesture. The gesture will not be recognized if one of\n * these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the disable key is never down.\n * @param {number} [options.minInputs=1] - The minimum number of pointers that\n * must be active for the gesture to be recognized. Uses >=.\n * @param {number} [options.maxInputs=Number.MAX_VALUE] - The maximum number of\n * pointers that may be active for the gesture to be recognized. Uses <=.\n * @param {number} [options.minDelay=0] - The minimum delay between a touchstart\n * and touchend can be configured in milliseconds.\n * @param {number} [options.maxDelay=300] - The maximum delay between a\n * touchstart and touchend can be configured in milliseconds.\n * @param {number} [options.numTaps=1] - Number of taps to require.\n * @param {number} [options.tolerance=10] - The tolerance in pixels a user can\n * move.\n */\nclass Tap extends Gesture {\n  constructor(element, handler, options = {}) {\n    options = { ...Tap.DEFAULTS, ...options };\n    super('tap', element, handler, options);\n\n    /**\n     * The minimum amount between a touchstart and a touchend can be configured\n     * in milliseconds. The minimum delay starts to count down when the expected\n     * number of inputs are on the screen, and ends when ALL inputs are off the\n     * screen.\n     *\n     * @type {number}\n     */\n    this.minDelay = options.minDelay;\n\n    /**\n     * The maximum delay between a touchstart and touchend can be configured in\n     * milliseconds. The maximum delay starts to count down when the expected\n     * number of inputs are on the screen, and ends when ALL inputs are off the\n     * screen.\n     *\n     * @type {number}\n     */\n    this.maxDelay = options.maxDelay;\n\n    /**\n     * The number of inputs to trigger a Tap can be variable, and the maximum\n     * number being a factor of the browser.\n     *\n     * @type {number}\n     */\n    this.numTaps = options.numTaps;\n\n    /**\n     * A move tolerance in pixels allows some slop between a user's start to end\n     * events. This allows the Tap gesture to be triggered more easily.\n     *\n     * @type {number}\n     */\n    this.tolerance = options.tolerance;\n\n    /**\n     * An array of inputs that have ended recently.\n     *\n     * @type {Input[]}\n     */\n    this.taps = [];\n  }\n\n  end(state) {\n    const now = Date.now();\n\n    // Save the recently ended inputs as taps.\n    this.taps = this.taps.concat(state.getInputsInPhase('end'))\n      .filter(input => {\n        const tdiff = now - input.startTime;\n        return tdiff <= this.maxDelay && tdiff >= this.minDelay;\n      });\n\n    // Validate the list of taps.\n    if (this.taps.length !== this.numTaps ||\n      this.taps.some(i => i.totalDistance() > this.tolerance)) {\n      return null;\n    }\n\n    const centroid = Point2D.centroid(this.taps.map(i => i.current.point));\n    this.taps = []; // Critical! Used taps need to be cleared!\n    return { centroid, ...centroid };\n  }\n}\n\nTap.DEFAULTS = Object.freeze({\n  minDelay:  0,\n  maxDelay:  300,\n  numTaps:   1,\n  tolerance: 10,\n});\n\nmodule.exports = Tap;\n\n","/*\n * Contains the Track class.\n */\n\n'use strict';\n\nconst { Gesture } = require('westures-core');\n\n/**\n * Data returned when a Track is recognized.\n *\n * @typedef {Object} TrackData\n * @mixes ReturnTypes.BaseData\n *\n * @property {westures-core.Point2D[]} active - Points currently in 'start' or\n *    'move' phase.\n *\n * @memberof ReturnTypes\n */\n\n/**\n * A Track gesture forwards a list of active points and their centroid on each\n * of the selected phases.\n *\n * @extends westures-core.Gesture\n * @see {ReturnTypes.TrackData}\n * @memberof westures\n *\n * @param {Element} element - The element to which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n * is recognized on the associated element.\n * @param {object} [options] - Gesture customization options.\n * @param {westures-core.STATE_KEYS[]} [options.enableKeys=[]] - List of keys\n * which will enable the gesture. The gesture will not be recognized unless one\n * of these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the enable key is always down.\n * @param {westures-core.STATE_KEYS[]} [options.disableKeys=[]] - List of keys\n * which will disable the gesture. The gesture will not be recognized if one of\n * these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the disable key is never down.\n * @param {number} [options.minInputs=1] - The minimum number of pointers that\n * must be active for the gesture to be recognized. Uses >=.\n * @param {number} [options.maxInputs=Number.MAX_VALUE] - The maximum number of\n * pointers that may be active for the gesture to be recognized. Uses <=.\n * @param {string[]} [options.phases=[]] Phases to recognize. Entries can be any\n * or all of 'start', 'move', 'end', and 'cancel'.\n */\nclass Track extends Gesture {\n  constructor(element, handler, options = {}) {\n    options = { ...Track.DEFAULTS, ...options };\n    super('track', element, handler, options);\n\n    this.trackStart  = options.phases.includes('start');\n    this.trackMove   = options.phases.includes('move');\n    this.trackEnd    = options.phases.includes('end');\n    this.trackCancel = options.phases.includes('cancel');\n  }\n\n  /**\n   * Filters out the state's data, down to what should be emitted.\n\n   * @param {State} state - current input state.\n   * @return {ReturnTypes.TrackData}\n   */\n  data({ activePoints }) {\n    return { active: activePoints };\n  }\n\n  start(state) {\n    return this.trackStart ? this.data(state) : null;\n  }\n\n  move(state) {\n    return this.trackMove ? this.data(state) : null;\n  }\n\n  end(state) {\n    return this.trackEnd ? this.data(state) : null;\n  }\n\n  cancel(state) {\n    return this.trackCancel ? this.data(state) : null;\n  }\n}\n\nTrack.DEFAULTS = Object.freeze({\n  phases: Object.freeze([]),\n});\n\nmodule.exports = Track;\n\n","'use strict';\n\nconst westures = require('westures');\nconst region = new westures.Region(document.body);\nconst container = document.querySelector('#container');\n\nconst SIXTY_FPS = 1000 / 60;\nconst FRICTION = 0.95;\nconst MULTI = 7;\nconst LIMIT = 0.1;\nconst MAX_V = 7;\n\nfunction random8Bit() {\n  return Math.floor(Math.random() * 256);\n}\n\nfunction reduce(value) {\n  value *= FRICTION;\n  return (Math.abs(value) < LIMIT) ? 0 : value;\n}\n\n/**\n * Provides an interactable element using westures.\n */\nclass Interactable {\n  constructor(name, color) {\n    this.element = document.createElement('div');\n    this.element.style.backgroundColor = color;\n\n    this.label = document.createElement('h1');\n    this.label.innerText = name;\n\n    this.element.appendChild(this.label);\n    container.appendChild(this.element);\n\n    this.rotation = 0;\n    this.scale = 1;\n    this.x = 0;\n    this.y = 0;\n    this.velocityX = 0;\n    this.velocityY = 0;\n\n    this.animate = false;\n    this.update_fn = this.update.bind(this);\n    this.swipe_interval = null;\n    this.swipe_fn = this.swipeAnimation.bind(this);\n\n    this.setupTracking();\n  }\n\n  /**\n   * Setups up tracking of the interactable element.\n   */\n  setupTracking() {\n    region.addGesture(new westures.Track(\n      this.element,\n      (data) => {\n        switch (data.phase) {\n        case 'start':\n          this.animate = true;\n          window.requestAnimationFrame(this.update_fn);\n          clearInterval(this.swipe_interval);\n          break;\n        case 'end':\n          if (data.active.length == 0) {\n            this.animate = false;\n          }\n          break;\n        default:\n          break;\n        }\n      },\n      {\n        phases: ['start', 'end'],\n      },\n    ));\n  }\n\n  randomBackground() {\n    const R = random8Bit();\n    const G = random8Bit();\n    const B = random8Bit();\n    this.element.style.backgroundColor = `rgb(${R}, ${G}, ${B})`;\n  }\n\n  addTap(options) {\n    region.addGesture(new westures.Tap(\n      this.element,\n      () => {\n        this.randomBackground();\n      },\n      options,\n    ));\n    return this;\n  }\n\n  addPress(options) {\n    region.addGesture(new westures.Press(\n      this.element,\n      () => {\n        this.randomBackground();\n      },\n      options,\n    ));\n    return this;\n  }\n\n  addRotate(options) {\n    region.addGesture(new westures.Rotate(\n      this.element,\n      (data) => {\n        this.rotation += data.rotation;\n      },\n      options,\n    ));\n    return this;\n  }\n\n  addPan(options) {\n    region.addGesture(new westures.Pan(\n      this.element,\n      (data) => {\n        this.x += data.translation.x;\n        this.y += data.translation.y;\n      },\n      options,\n    ));\n    return this;\n  }\n\n  addSwipe(options) {\n    region.addGesture(new westures.Swipe(\n      this.element,\n      (data) => {\n        const velocity = data.velocity > MAX_V ? MAX_V : data.velocity;\n        this.velocityX = velocity * Math.cos(data.direction) * MULTI;\n        this.velocityY = velocity * Math.sin(data.direction) * MULTI;\n        this.swipe_interval = setInterval(this.swipe_fn, SIXTY_FPS);\n      },\n      options,\n    ));\n    return this;\n  }\n\n  addSwivel(options) {\n    region.addGesture(new westures.Swivel(\n      this.element,\n      (data) => {\n        this.rotation += data.rotation;\n      },\n      {\n        pivotCenter: this.element,\n        ...options,\n      },\n    ));\n    return this;\n  }\n\n  addPinch(options) {\n    region.addGesture(new westures.Pinch(\n      this.element,\n      (data) => {\n        this.scale *= data.scale;\n      },\n      options,\n    ));\n    return this;\n  }\n\n  addPull(options) {\n    region.addGesture(new westures.Pull(\n      this.element,\n      (data) => {\n        this.scale *= data.scale;\n      },\n      {\n        pivotCenter: this.element,\n        ...options,\n      },\n    ));\n    return this;\n  }\n\n  update() {\n    const rotate = `rotate(${this.rotation}rad) `;\n    const translate = `translate(${this.x}px, ${this.y}px) `;\n    const scale = `scale(${this.scale}) `;\n    this.element.style.transform = translate + rotate + scale;\n\n    if (this.animate) {\n      window.requestAnimationFrame(this.update_fn);\n    }\n  }\n\n  swipeAnimation() {\n    this.x += this.velocityX;\n    this.y += this.velocityY;\n    this.velocityX = reduce(this.velocityX);\n    this.velocityY = reduce(this.velocityY);\n    if (this.velocityY === 0 && this.velocityX === 0) {\n      clearInterval(this.swipe_interval);\n    }\n    window.requestAnimationFrame(this.update_fn);\n  }\n}\n\n/* ========================================================================== */\n\nconst NUM_COLOURS = 12;\nconst INTERVAL = Math.floor(360 / NUM_COLOURS);\nconst PALETTE = [];\n\n// Generate a Pastel Rainbow\nfor (let i = 0; i < NUM_COLOURS; i++) {\n  const hue = INTERVAL * i;\n  PALETTE.push(`hsl(${hue}, 100%, 75%)`);\n}\n\nlet cidx = 0;\nfunction nextColour() {\n  return PALETTE[cidx++];\n}\n\n// Basic gestures\nnew Interactable('TAP',    nextColour()).addTap();\nnew Interactable('PAN',    nextColour()).addPan();\nnew Interactable('PINCH',  nextColour()).addPinch();\nnew Interactable('ROTATE', nextColour()).addRotate();\nnew Interactable('SWIPE',  nextColour()).addSwipe();\nnew Interactable('PRESS',  nextColour()).addPress();\nnew Interactable('SWIVEL', nextColour()).addSwivel();\nnew Interactable('PULL',   nextColour()).addPull();\n\n// Mix and match!\n// new Interactable('ROTATE and SWIVEL', 'forestgreen').addRotate().addSwivel();\nnew Interactable(\n  'TAP, PAN, PINCH, SWIPE, and ROTATE\\n(desktop: CTRL to SWIVEL and PULL)',\n  nextColour(),\n).addTap()\n  .addPan({ disableKeys: ['ctrlKey'] })\n  .addPinch()\n  .addRotate()\n  .addSwipe()\n  .addSwivel({ enableKeys: ['ctrlKey'] })\n  .addPull({ enableKeys: ['ctrlKey'] });\nnew Interactable('DOUBLE TAP', nextColour()).addTap({\n  numTaps: 2,\n});\nnew Interactable('FIVE TAPS', nextColour()).addTap({\n  maxDelay: 1000,\n  numTaps:  5,\n});\nnew Interactable('SLOW TAP', nextColour()).addTap({\n  minDelay: 300,\n  maxDelay: 1000,\n});\n","/**\n * The API interface for Westures. Defines a number of gestures on top of the\n * engine provided by {@link\n * https://mvanderkamp.github.io/westures-core/index.html|westures-core}.\n *\n * @namespace westures\n */\n\n'use strict';\n\nconst core = require('westures-core');\n\nconst Pan     = require('./src/Pan.js');\nconst Pinch   = require('./src/Pinch.js');\nconst Press   = require('./src/Press.js');\nconst Pull    = require('./src/Pull.js');\nconst Rotate  = require('./src/Rotate.js');\nconst Swipe   = require('./src/Swipe.js');\nconst Swivel  = require('./src/Swivel.js');\nconst Tap     = require('./src/Tap.js');\nconst Track   = require('./src/Track.js');\n\nmodule.exports = {\n  Pan,\n  Pinch,\n  Press,\n  Pull,\n  Rotate,\n  Swipe,\n  Swivel,\n  Tap,\n  Track,\n  ...core,\n};\n\n/**\n * Here are the return \"types\" of the gestures that are included in this\n * package.\n *\n * @namespace ReturnTypes\n */\n\n/**\n * The base data that is included for all emitted gestures.\n *\n * @typedef {Object} BaseData\n *\n * @property {westures-core.Point2D} centroid - The centroid of the input\n * points.\n * @property {Event} event - The input event which caused the gesture to be\n * recognized.\n * @property {string} phase - 'start', 'move', 'end', or 'cancel'.\n * @property {number} radius - The distance of the furthest input to the\n * centroid.\n * @property {string} type - The name of the gesture as specified by its\n * designer.\n * @property {Element} target - The bound target of the gesture.\n *\n * @memberof ReturnTypes\n */\n\n"]}